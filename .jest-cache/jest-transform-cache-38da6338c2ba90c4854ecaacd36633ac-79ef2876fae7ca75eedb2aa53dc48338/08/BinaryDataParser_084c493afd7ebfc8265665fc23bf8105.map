{"file":"/home/share/samba/vscode-extension/pico-logicanalyzer/src/models/BinaryDataParser.ts","mappings":"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","names":[],"sources":["/home/share/samba/vscode-extension/pico-logicanalyzer/src/models/BinaryDataParser.ts"],"sourcesContent":["/**\r\n * 二进制数据解析和通道提取器\r\n * 基于原版 C# 的数据解析逻辑，专门处理逻辑分析器的二进制数据格式\r\n * 支持多种数据格式和压缩算法\r\n */\r\n\r\nimport { CaptureMode } from './AnalyzerTypes';\r\nimport { AnalyzerChannel, CaptureSession } from './CaptureModels';\r\nimport { UnifiedCaptureData, DigitalSampleData } from './UnifiedDataFormat';\r\n\r\n/**\r\n * 二进制数据格式\r\n */\r\nexport enum BinaryDataFormat {\r\n  Raw = 'raw',           // 原始二进制数据\r\n  Compressed = 'compressed', // 压缩数据\r\n  RLE = 'rle',          // 行程长度编码\r\n  Delta = 'delta'       // 差分编码\r\n}\r\n\r\n/**\r\n * 数据解析配置\r\n */\r\nexport interface BinaryParserConfig {\r\n  format: BinaryDataFormat;\r\n  compressionThreshold: number; // 压缩阈值 (字节)\r\n  enableOptimization: boolean; // 启用优化\r\n  chunkSize: number; // 处理块大小\r\n  enableValidation: boolean; // 启用数据验证\r\n}\r\n\r\n/**\r\n * 通道提取配置\r\n */\r\nexport interface ChannelExtractionConfig {\r\n  channelMask: number; // 通道掩码\r\n  bitOffset: number; // 位偏移\r\n  invertLogic: boolean; // 逻辑反转\r\n  enableFiltering: boolean; // 启用滤波\r\n  filterWidth: number; // 滤波器宽度\r\n}\r\n\r\n/**\r\n * 数据解析结果\r\n */\r\nexport interface ParseResult {\r\n  success: boolean;\r\n  channels: AnalyzerChannel[];\r\n  totalSamples: number;\r\n  compressionRatio?: number;\r\n  parseTime: number; // 解析耗时 (ms)\r\n  memoryUsage: number; // 内存使用量 (bytes)\r\n  warnings: string[]; // 警告信息\r\n}\r\n\r\n/**\r\n * 二进制数据解析器\r\n */\r\nexport class BinaryDataParser {\r\n  private config: BinaryParserConfig;\r\n  private parseStartTime: number = 0;\r\n\r\n  constructor(config: Partial<BinaryParserConfig> = {}) {\r\n    this.config = {\r\n      format: BinaryDataFormat.Raw,\r\n      compressionThreshold: 1024 * 1024, // 1MB\r\n      enableOptimization: true,\r\n      chunkSize: 64 * 1024, // 64KB\r\n      enableValidation: true,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 解析二进制数据并提取通道信息\r\n   */\r\n  public async parseBinaryData(\r\n    rawData: Uint8Array,\r\n    session: CaptureSession,\r\n    mode: CaptureMode\r\n  ): Promise<ParseResult> {\r\n\r\n    this.parseStartTime = performance.now();\r\n    const warnings: string[] = [];\r\n\r\n    try {\r\n      // 数据验证\r\n      if (this.config.enableValidation) {\r\n        const validationResult = this.validateRawData(rawData, session, mode);\r\n        if (!validationResult.isValid) {\r\n          throw new Error(`Data validation failed: ${validationResult.error}`);\r\n        }\r\n        warnings.push(...validationResult.warnings);\r\n      }\r\n\r\n      // 解析数据头部\r\n      const headerInfo = this.parseDataHeader(rawData, mode);\r\n\r\n      // 根据采集模式提取样本数据\r\n      const sampleData = this.extractSampleData(rawData, headerInfo, mode);\r\n\r\n      // 提取各个通道的数据\r\n      const channels = await this.extractChannelData(sampleData, session, mode);\r\n\r\n      // 应用优化处理\r\n      if (this.config.enableOptimization) {\r\n        await this.optimizeChannelData(channels);\r\n      }\r\n\r\n      const parseTime = performance.now() - this.parseStartTime;\r\n      const memoryUsage = this.calculateMemoryUsage(channels);\r\n\r\n      return {\r\n        success: true,\r\n        channels,\r\n        totalSamples: headerInfo.sampleCount,\r\n        parseTime,\r\n        memoryUsage,\r\n        warnings\r\n      };\r\n\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        channels: [],\r\n        totalSamples: 0,\r\n        parseTime: performance.now() - this.parseStartTime,\r\n        memoryUsage: 0,\r\n        warnings: [...warnings, `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}`]\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 验证原始数据\r\n   */\r\n  private validateRawData(\r\n    data: Uint8Array,\r\n    session: CaptureSession,\r\n    mode: CaptureMode\r\n  ): { isValid: boolean; error?: string; warnings: string[] } {\r\n\r\n    const warnings: string[] = [];\r\n\r\n    // 最小数据长度检查\r\n    if (data.length < 8) {\r\n      return { isValid: false, error: 'Data too short (minimum 8 bytes required)', warnings };\r\n    }\r\n\r\n    // 计算期望的数据长度\r\n    const bytesPerSample = mode === CaptureMode.Channels_8 ? 1 :\r\n                          (mode === CaptureMode.Channels_16 ? 2 : 4);\r\n    const expectedHeaderSize = 4; // uint32 sample count\r\n    const expectedSampleSize = session.totalSamples * bytesPerSample;\r\n    const expectedTotalSize = expectedHeaderSize + expectedSampleSize + 1; // +1 for timestamp length\r\n\r\n    if (data.length < expectedTotalSize) {\r\n      warnings.push(`Data length ${data.length} is less than expected ${expectedTotalSize}`);\r\n    }\r\n\r\n    // 检查采集模式的合理性\r\n    if (session.captureChannels.length === 0) {\r\n      return { isValid: false, error: 'No capture channels defined', warnings };\r\n    }\r\n\r\n    const maxChannelNumber = Math.max(...session.captureChannels.map(ch => ch.channelNumber));\r\n    const maxSupportedChannels = mode === CaptureMode.Channels_8 ? 8 :\r\n                                (mode === CaptureMode.Channels_16 ? 16 : 24);\r\n\r\n    if (maxChannelNumber >= maxSupportedChannels) {\r\n      return {\r\n        isValid: false,\r\n        error: `Channel ${maxChannelNumber} exceeds max supported channels ${maxSupportedChannels} for mode ${mode}`,\r\n        warnings\r\n      };\r\n    }\r\n\r\n    return { isValid: true, warnings };\r\n  }\r\n\r\n  /**\r\n   * 解析数据头部信息\r\n   */\r\n  private parseDataHeader(data: Uint8Array, mode: CaptureMode): {\r\n    sampleCount: number;\r\n    dataOffset: number;\r\n    bytesPerSample: number;\r\n  } {\r\n\r\n    const view = new DataView(data.buffer, data.byteOffset);\r\n\r\n    // 读取样本数量 (uint32, little endian)\r\n    const sampleCount = view.getUint32(0, true);\r\n\r\n    const bytesPerSample = mode === CaptureMode.Channels_8 ? 1 :\r\n                          (mode === CaptureMode.Channels_16 ? 2 : 4);\r\n\r\n    return {\r\n      sampleCount,\r\n      dataOffset: 4, // 跳过样本数量字段\r\n      bytesPerSample\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 提取样本数据\r\n   */\r\n  private extractSampleData(\r\n    data: Uint8Array,\r\n    headerInfo: { sampleCount: number; dataOffset: number; bytesPerSample: number },\r\n    mode: CaptureMode\r\n  ): Uint32Array {\r\n\r\n    const { sampleCount, dataOffset, bytesPerSample } = headerInfo;\r\n    const samples = new Uint32Array(sampleCount);\r\n    const view = new DataView(data.buffer, data.byteOffset + dataOffset);\r\n\r\n    // 根据采集模式读取不同大小的数据\r\n    for (let i = 0; i < sampleCount; i++) {\r\n      const offset = i * bytesPerSample;\r\n\r\n      switch (mode) {\r\n        case CaptureMode.Channels_8:\r\n          samples[i] = view.getUint8(offset);\r\n          break;\r\n        case CaptureMode.Channels_16:\r\n          samples[i] = view.getUint16(offset, true); // little endian\r\n          break;\r\n        case CaptureMode.Channels_24:\r\n          samples[i] = view.getUint32(offset, true); // little endian\r\n          break;\r\n      }\r\n    }\r\n\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * 提取通道数据 - 基于C# ExtractSamples方法\r\n   */\r\n  private async extractChannelData(\r\n    sampleData: Uint32Array,\r\n    session: CaptureSession,\r\n    mode: CaptureMode\r\n  ): Promise<AnalyzerChannel[]> {\r\n\r\n    const channels: AnalyzerChannel[] = [];\r\n\r\n    for (let channelIndex = 0; channelIndex < session.captureChannels.length; channelIndex++) {\r\n      const originalChannel = session.captureChannels[channelIndex];\r\n      const newChannel = originalChannel.clone();\r\n\r\n      // 提取该通道的样本数据\r\n      const channelSamples = this.extractSingleChannelData(\r\n        sampleData,\r\n        originalChannel.channelNumber,\r\n        mode\r\n      );\r\n\r\n      newChannel.samples = channelSamples;\r\n      channels.push(newChannel);\r\n    }\r\n\r\n    return channels;\r\n  }\r\n\r\n  /**\r\n   * 提取单个通道的数据\r\n   */\r\n  private extractSingleChannelData(\r\n    sampleData: Uint32Array,\r\n    channelNumber: number,\r\n    mode: CaptureMode\r\n  ): Uint8Array {\r\n\r\n    const mask = 1 << channelNumber;\r\n    const channelSamples = new Uint8Array(sampleData.length);\r\n\r\n    // 使用位掩码提取通道数据\r\n    for (let i = 0; i < sampleData.length; i++) {\r\n      channelSamples[i] = (sampleData[i] & mask) !== 0 ? 1 : 0;\r\n    }\r\n\r\n    return channelSamples;\r\n  }\r\n\r\n  /**\r\n   * 优化通道数据\r\n   */\r\n  private async optimizeChannelData(channels: AnalyzerChannel[]): Promise<void> {\r\n    for (const channel of channels) {\r\n      if (channel.samples && channel.samples.length > this.config.compressionThreshold) {\r\n        // 应用数据压缩优化\r\n        const optimized = this.compressChannelData(channel.samples);\r\n        if (optimized.length < channel.samples.length * 0.8) { // 压缩率 > 20%\r\n          // 这里可以实现压缩存储，但为了兼容性暂时保持原格式\r\n          // channel.samples = optimized;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 压缩通道数据 - 使用RLE算法\r\n   */\r\n  private compressChannelData(data: Uint8Array): Uint8Array {\r\n    const compressed: number[] = [];\r\n    let currentValue = data[0];\r\n    let count = 1;\r\n\r\n    for (let i = 1; i < data.length; i++) {\r\n      if (data[i] === currentValue && count < 255) {\r\n        count++;\r\n      } else {\r\n        // 写入当前值和计数\r\n        compressed.push(currentValue, count);\r\n        currentValue = data[i];\r\n        count = 1;\r\n      }\r\n    }\r\n\r\n    // 写入最后一组\r\n    compressed.push(currentValue, count);\r\n\r\n    return new Uint8Array(compressed);\r\n  }\r\n\r\n  /**\r\n   * 解压缩通道数据 - RLE解压\r\n   */\r\n  private decompressChannelData(compressedData: Uint8Array): Uint8Array {\r\n    const decompressed: number[] = [];\r\n\r\n    for (let i = 0; i < compressedData.length; i += 2) {\r\n      const value = compressedData[i];\r\n      const count = compressedData[i + 1];\r\n\r\n      for (let j = 0; j < count; j++) {\r\n        decompressed.push(value);\r\n      }\r\n    }\r\n\r\n    return new Uint8Array(decompressed);\r\n  }\r\n\r\n  /**\r\n   * 计算内存使用量\r\n   */\r\n  private calculateMemoryUsage(channels: AnalyzerChannel[]): number {\r\n    let totalMemory = 0;\r\n\r\n    for (const channel of channels) {\r\n      if (channel.samples) {\r\n        totalMemory += channel.samples.byteLength;\r\n      }\r\n      // 加上对象本身的内存估算\r\n      totalMemory += 64; // 估算对象开销\r\n    }\r\n\r\n    return totalMemory;\r\n  }\r\n\r\n  /**\r\n   * 转换为统一数据格式\r\n   */\r\n  public convertToUnifiedFormat(\r\n    channels: AnalyzerChannel[],\r\n    session: CaptureSession,\r\n    deviceInfo: any\r\n  ): DigitalSampleData {\r\n\r\n    return {\r\n      data: channels.map(ch => ch.samples || new Uint8Array()),\r\n      encoding: 'binary',\r\n      compression: 'none'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 从统一数据格式转换\r\n   */\r\n  public convertFromUnifiedFormat(\r\n    digitalData: DigitalSampleData,\r\n    channelInfo: { channelNumber: number; channelName: string }[]\r\n  ): AnalyzerChannel[] {\r\n\r\n    const channels: AnalyzerChannel[] = [];\r\n\r\n    for (let i = 0; i < digitalData.data.length && i < channelInfo.length; i++) {\r\n      const channel = new AnalyzerChannel(\r\n        channelInfo[i].channelNumber,\r\n        channelInfo[i].channelName\r\n      );\r\n\r\n      if (digitalData.encoding === 'rle') {\r\n        channel.samples = this.decompressChannelData(digitalData.data[i]);\r\n      } else {\r\n        channel.samples = digitalData.data[i];\r\n      }\r\n\r\n      channels.push(channel);\r\n    }\r\n\r\n    return channels;\r\n  }\r\n\r\n  /**\r\n   * 高级通道提取 - 支持复杂的通道配置\r\n   */\r\n  public extractChannelsAdvanced(\r\n    sampleData: Uint32Array,\r\n    configs: ChannelExtractionConfig[]\r\n  ): Uint8Array[] {\r\n\r\n    const results: Uint8Array[] = [];\r\n\r\n    for (const config of configs) {\r\n      const channelData = new Uint8Array(sampleData.length);\r\n\r\n      for (let i = 0; i < sampleData.length; i++) {\r\n        let value = (sampleData[i] & config.channelMask) >> config.bitOffset;\r\n\r\n        if (config.invertLogic) {\r\n          value = value ? 0 : 1;\r\n        }\r\n\r\n        channelData[i] = value & 0xFF;\r\n      }\r\n\r\n      // 应用滤波\r\n      if (config.enableFiltering && config.filterWidth > 1) {\r\n        this.applyMedianFilter(channelData, config.filterWidth);\r\n      }\r\n\r\n      results.push(channelData);\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * 应用中值滤波器\r\n   */\r\n  private applyMedianFilter(data: Uint8Array, width: number): void {\r\n    const halfWidth = Math.floor(width / 2);\r\n    const filtered = new Uint8Array(data.length);\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n      const start = Math.max(0, i - halfWidth);\r\n      const end = Math.min(data.length - 1, i + halfWidth);\r\n      const window = Array.from(data.slice(start, end + 1)).sort((a, b) => a - b);\r\n      filtered[i] = window[Math.floor(window.length / 2)];\r\n    }\r\n\r\n    data.set(filtered);\r\n  }\r\n\r\n  /**\r\n   * 数据完整性检查\r\n   */\r\n  public validateDataIntegrity(channels: AnalyzerChannel[]): {\r\n    isValid: boolean;\r\n    errors: string[];\r\n    statistics: {\r\n      totalSamples: number;\r\n      channelsWithData: number;\r\n      averageSampleRate: number;\r\n    };\r\n  } {\r\n\r\n    const errors: string[] = [];\r\n    let totalSamples = 0;\r\n    let channelsWithData = 0;\r\n\r\n    for (const channel of channels) {\r\n      if (!channel.samples) {\r\n        errors.push(`Channel ${channel.channelNumber} has no sample data`);\r\n        continue;\r\n      }\r\n\r\n      if (channel.samples.length === 0) {\r\n        errors.push(`Channel ${channel.channelNumber} has empty sample data`);\r\n        continue;\r\n      }\r\n\r\n      // 检查数据值范围\r\n      for (let i = 0; i < channel.samples.length; i++) {\r\n        if (channel.samples[i] > 1) {\r\n          errors.push(`Channel ${channel.channelNumber} has invalid value ${channel.samples[i]} at sample ${i}`);\r\n          break;\r\n        }\r\n      }\r\n\r\n      totalSamples = Math.max(totalSamples, channel.samples.length);\r\n      channelsWithData++;\r\n    }\r\n\r\n    // 检查所有通道的样本数量是否一致\r\n    for (const channel of channels) {\r\n      if (channel.samples && channel.samples.length !== totalSamples) {\r\n        errors.push(`Channel ${channel.channelNumber} sample count ${channel.samples.length} differs from expected ${totalSamples}`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      statistics: {\r\n        totalSamples,\r\n        channelsWithData,\r\n        averageSampleRate: totalSamples > 0 ? totalSamples / channels.length : 0\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 更新配置\r\n   */\r\n  public updateConfig(config: Partial<BinaryParserConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * 获取当前配置\r\n   */\r\n  public getConfig(): BinaryParserConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n\r\n/**\r\n * 二进制数据解析工厂\r\n */\r\nexport class BinaryDataParserFactory {\r\n  /**\r\n   * 创建针对特定设备优化的解析器\r\n   */\r\n  public static createForDevice(deviceType: string, channelCount: number): BinaryDataParser {\r\n    const config: Partial<BinaryParserConfig> = {\r\n      enableOptimization: true,\r\n      enableValidation: true\r\n    };\r\n\r\n    // 根据设备类型调整配置\r\n    switch (deviceType.toLowerCase()) {\r\n      case 'pico':\r\n        config.chunkSize = 32 * 1024; // 32KB chunks for Pico\r\n        config.compressionThreshold = 512 * 1024; // 512KB\r\n        break;\r\n      case 'saleae':\r\n        config.chunkSize = 128 * 1024; // 128KB chunks for Saleae\r\n        config.compressionThreshold = 2 * 1024 * 1024; // 2MB\r\n        break;\r\n      default:\r\n        config.chunkSize = 64 * 1024; // Default 64KB\r\n        config.compressionThreshold = 1024 * 1024; // Default 1MB\r\n    }\r\n\r\n    return new BinaryDataParser(config);\r\n  }\r\n\r\n  /**\r\n   * 创建高性能解析器\r\n   */\r\n  public static createHighPerformance(): BinaryDataParser {\r\n    return new BinaryDataParser({\r\n      format: BinaryDataFormat.Raw,\r\n      enableOptimization: true,\r\n      enableValidation: false, // 关闭验证以提高性能\r\n      chunkSize: 256 * 1024, // 大块处理\r\n      compressionThreshold: 10 * 1024 * 1024 // 10MB\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 创建调试用解析器\r\n   */\r\n  public static createDebug(): BinaryDataParser {\r\n    return new BinaryDataParser({\r\n      format: BinaryDataFormat.Raw,\r\n      enableOptimization: false,\r\n      enableValidation: true,\r\n      chunkSize: 4 * 1024, // 小块处理便于调试\r\n      compressionThreshold: 64 * 1024 // 64KB\r\n    });\r\n  }\r\n}\n"],"version":3}