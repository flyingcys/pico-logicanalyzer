{"file":"/home/share/samba/vscode-extension/pico-logicanalyzer/src/decoders/DecoderBase.ts","mappings":"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","names":[],"sources":["/home/share/samba/vscode-extension/pico-logicanalyzer/src/decoders/DecoderBase.ts"],"sourcesContent":["/**\n * TypeScript解码器基类\n * 基于 @logicanalyzer/Software 的 SigrokDecoderBase 架构\n * 实现纯TypeScript零依赖的协议解码功能\n */\n\nimport {\n  DecoderChannel,\n  DecoderOption,\n  DecoderOptionValue,\n  DecoderSelectedChannel,\n  WaitCondition,\n  WaitConditions,\n  WaitResult,\n  DecoderOutput,\n  DecoderResult,\n  DecoderOutputType,\n  WaitConditionType,\n  ChannelData\n} from './types';\n\n/**\n * 解码器抽象基类\n * 所有协议解码器必须继承此基类\n */\nexport abstract class DecoderBase {\n  // 解码器元数据 - 子类必须实现\n  abstract readonly id: string;\n  abstract readonly name: string;\n  abstract readonly longname: string;\n  abstract readonly desc: string;\n  abstract readonly license: string;\n  abstract readonly inputs: string[];\n  abstract readonly outputs: string[];\n  abstract readonly tags: string[];\n  abstract readonly channels: DecoderChannel[];\n  abstract readonly options: DecoderOption[];\n  abstract readonly annotations: Array<[string, string, string?]>;\n  abstract readonly annotationRows?: Array<[string, string, number[]]>;\n\n  // 解码状态管理\n  protected sampleIndex: number = 0;\n  protected sampleRate: number = 0;\n  protected channelData: Uint8Array[] = [];\n  protected results: DecoderResult[] = [];\n  protected registeredOutputs: Map<DecoderOutputType, number> = new Map();\n  protected currentState: Map<number, number> = new Map();\n  protected lastState: Map<number, number> = new Map();\n\n  /**\n   * 主解码方法 - 子类必须实现\n   * @param sampleRate 采样率\n   * @param channels 通道数据\n   * @param options 配置选项\n   * @returns 解码结果数组\n   */\n  abstract decode(\n    _sampleRate: number,\n    _channels: ChannelData[],\n    _options: DecoderOptionValue[]\n  ): DecoderResult[];\n\n  /**\n   * 初始化解码器\n   * 对应原软件的 start() 方法\n   */\n  protected start(): void {\n    // 注册默认输出类型\n    this.register(DecoderOutputType.ANNOTATION);\n    this.register(DecoderOutputType.PYTHON);\n\n    // 重置状态\n    this.reset();\n  }\n\n  /**\n   * 重置解码器状态\n   * 对应原软件的 reset() 方法\n   */\n  protected reset(): void {\n    this.sampleIndex = 0;\n    this.results = [];\n    this.currentState.clear();\n    this.lastState.clear();\n  }\n\n  /**\n   * 注册输出类型\n   * 对应原软件的 register() 方法\n   * @param outputType 输出类型\n   * @returns 输出ID\n   */\n  protected register(outputType: DecoderOutputType): number {\n    const outputId = this.registeredOutputs.size;\n    this.registeredOutputs.set(outputType, outputId);\n    return outputId;\n  }\n\n  /**\n   * 等待指定的通道条件 - 核心API\n   * 对应原软件的 Wait() 方法\n   * @param conditions 等待条件（单个条件或条件数组）\n   * @returns 等待结果\n   */\n  protected wait(conditions: WaitConditions): WaitResult {\n    if (this.channelData.length === 0) {\n      throw new Error('No channel data available');\n    }\n\n    const maxSamples = this.channelData[0].length;\n\n    // 保存上一个状态\n    this.saveCurrentState();\n\n    // 转换为条件数组格式\n    const conditionsArray = Array.isArray(conditions) ? conditions : [conditions];\n\n    // 如果是单个跳过条件，直接返回当前状态\n    if (conditionsArray.length === 1 && this.isSkipCondition(conditionsArray[0])) {\n      return {\n        pins: this.getCurrentPins(),\n        sampleNumber: this.sampleIndex\n      };\n    }\n\n    // 主搜索循环\n    while (this.sampleIndex < maxSamples) {\n      // 更新当前状态\n      this.updateCurrentState();\n\n      // 检查每个条件是否匹配\n      for (let i = 0; i < conditionsArray.length; i++) {\n        const matched = this.checkConditions(conditionsArray[i]);\n        if (matched.every(m => m)) {\n          // 创建 matched 数组，对应原版的 self.matched\n          const matchedArray = new Array(conditionsArray.length).fill(false);\n          matchedArray[i] = true;\n\n          return {\n            pins: this.getCurrentPins(),\n            sampleNumber: this.sampleIndex,\n            matched: matchedArray,\n            matchedIndex: i\n          };\n        }\n      }\n\n      // 移动到下一个样本\n      this.sampleIndex++;\n    }\n\n    // 到达样本末尾\n    throw new Error('End of samples reached');\n  }\n\n  /**\n   * 输出解码结果 - 核心API\n   * 对应原软件的 Put() 方法\n   * @param startSample 开始样本\n   * @param endSample 结束样本\n   * @param data 输出数据\n   */\n  protected put(startSample: number, endSample: number, data: DecoderOutput): void {\n    const result: DecoderResult = {\n      startSample,\n      endSample,\n      annotationType: data.annotationType || 0,\n      values: data.values,\n      rawData: data.rawData,\n      shape: 'hexagon' // 默认形状\n    };\n\n    this.results.push(result);\n  }\n\n  /**\n   * 检查是否还有更多样本\n   * @returns 是否有更多样本\n   */\n  protected hasMoreSamples(): boolean {\n    return this.sampleIndex < (this.channelData[0]?.length || 0);\n  }\n\n  /**\n   * 获取当前所有通道的引脚状态\n   * @returns 引脚状态数组\n   */\n  protected getCurrentPins(): number[] {\n    return this.channelData.map(channel =>\n      this.sampleIndex < channel.length ? channel[this.sampleIndex] : 0\n    );\n  }\n\n  /**\n   * 检查条件是否匹配\n   * @param conditions 等待条件\n   * @returns 匹配结果数组\n   */\n  private checkConditions(conditions: WaitCondition): boolean[] {\n    const results: boolean[] = [];\n\n    for (const [channelIndex, conditionType] of Object.entries(conditions)) {\n      const chIndex = parseInt(channelIndex);\n      const matched = this.checkSingleCondition(chIndex, conditionType);\n      results.push(matched);\n    }\n\n    return results;\n  }\n\n  /**\n   * 检查单个通道条件\n   * @param channelIndex 通道索引\n   * @param conditionType 条件类型\n   * @returns 是否匹配\n   */\n  private checkSingleCondition(channelIndex: number, conditionType: WaitConditionType): boolean {\n    if (channelIndex >= this.channelData.length) {\n      return false;\n    }\n\n    const currentValue = this.currentState.get(channelIndex) || 0;\n    // 对于第一个样本，如果lastState中没有值，我们假设之前的值是0\n    const lastValue = this.lastState.has(channelIndex) ? this.lastState.get(channelIndex)! : 0;\n\n    switch (conditionType) {\n      case 'low':\n        return currentValue === 0;\n      case 'high':\n        return currentValue === 1;\n      case 'rising':\n        return lastValue === 0 && currentValue === 1;\n      case 'falling':\n        return lastValue === 1 && currentValue === 0;\n      case 'edge':\n        return lastValue !== currentValue;\n      case 'stable':\n        return lastValue === currentValue;\n      case 'skip':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * 保存当前状态为上一状态\n   */\n  private saveCurrentState(): void {\n    this.lastState.clear();\n    for (const [key, value] of this.currentState) {\n      this.lastState.set(key, value);\n    }\n  }\n\n  /**\n   * 更新当前状态\n   */\n  private updateCurrentState(): void {\n    this.saveCurrentState();\n    this.currentState.clear();\n\n    for (let i = 0; i < this.channelData.length; i++) {\n      const value =\n        this.sampleIndex < this.channelData[i].length ? this.channelData[i][this.sampleIndex] : 0;\n      this.currentState.set(i, value);\n    }\n  }\n\n  /**\n   * 检查是否为跳过条件\n   * @param conditions 条件\n   * @returns 是否为跳过条件\n   */\n  private isSkipCondition(conditions: WaitCondition): boolean {\n    const entries = Object.entries(conditions);\n    return entries.length === 1 && entries[0][0] === '0' && entries[0][1] === 'skip';\n  }\n\n  /**\n   * 检查引脚状态是否匹配条件\n   * @param pins 当前引脚状态\n   * @param conditions 条件\n   * @returns 是否匹配\n   */\n  protected matchesCondition(pins: number[], conditions: { [key: number]: WaitConditionType }): boolean {\n    for (const [channelIndexStr, conditionType] of Object.entries(conditions)) {\n      const channelIndex = parseInt(channelIndexStr);\n      if (channelIndex >= pins.length) {\n        return false;\n      }\n\n      const currentValue = pins[channelIndex];\n      const lastValue = this.lastState.get(channelIndex) || 0;\n\n      let matched = false;\n      switch (conditionType) {\n        case 'low':\n          matched = currentValue === 0;\n          break;\n        case 'high':\n          matched = currentValue === 1;\n          break;\n        case 'rising':\n          matched = lastValue === 0 && currentValue === 1;\n          break;\n        case 'falling':\n          matched = lastValue === 1 && currentValue === 0;\n          break;\n        case 'edge':\n          matched = lastValue !== currentValue;\n          break;\n        case 'stable':\n          matched = lastValue === currentValue;\n          break;\n        case 'skip':\n          matched = true;\n          break;\n        default:\n          matched = false;\n      }\n\n      if (!matched) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * 准备通道数据\n   * @param channels 通道数据\n   * @param channelMapping 通道映射\n   */\n  protected prepareChannelData(channels: ChannelData[], channelMapping: DecoderSelectedChannel[]): void {\n    this.channelData = [];\n\n    // 确定最大解码器索引以初始化数组大小\n    const maxDecoderIndex = channelMapping.reduce((max, mapping) =>\n      Math.max(max, mapping.decoderIndex), -1);\n\n    // 初始化所有通道数据为空数组\n    for (let i = 0; i <= maxDecoderIndex; i++) {\n      this.channelData[i] = new Uint8Array(channels[0]?.samples?.length || 0);\n    }\n\n    // 填充实际的通道数据\n    for (const mapping of channelMapping) {\n      if (mapping.captureIndex < channels.length && channels[mapping.captureIndex].samples) {\n        this.channelData[mapping.decoderIndex] = channels[mapping.captureIndex].samples;\n      }\n    }\n  }\n\n  /**\n   * 获取解码器信息\n   * @returns 解码器信息\n   */\n  public getInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      longname: this.longname,\n      description: this.desc,\n      license: this.license,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      tags: this.tags,\n      channels: this.channels,\n      options: this.options,\n      annotations: this.annotations,\n      annotationRows: this.annotationRows\n    };\n  }\n\n  /**\n   * 验证选项配置\n   * @param options 选项值\n   * @param selectedChannels 选中通道\n   * @param channels 通道数据\n   * @returns 是否有效\n   */\n  public validateOptions(\n    options: DecoderOptionValue[],\n    selectedChannels: DecoderSelectedChannel[],\n    _channels: ChannelData[]\n  ): boolean {\n    // 验证必需通道是否都已选择\n    const requiredChannels = this.channels.filter(ch => ch.required);\n    for (const reqChannel of requiredChannels) {\n      const hasChannel = selectedChannels.some(sel => sel.decoderIndex === (reqChannel.index || 0));\n      if (!hasChannel) {\n        return false;\n      }\n    }\n\n    // 验证选项值\n    for (const option of options) {\n      if (option.optionIndex >= this.options.length) {\n        return false;\n      }\n      // 可以添加更多选项验证逻辑\n    }\n\n    return true;\n  }\n\n}\n"],"version":3}