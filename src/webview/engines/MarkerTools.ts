/**
 * 标记工具 - 基于原版的SampleMarker功能
 * 处理用户标记、时间测量和分析功能
 */

import { AnalyzerChannel } from '../../models/CaptureModels';

export interface Marker {
  id: string;
  name: string;
  sample: number;
  timestamp: number; // 时间戳（秒）
  color: string;
  type: 'user' | 'trigger' | 'burst' | 'cursor' | 'measurement';
  visible: boolean;
  locked: boolean; // 是否锁定位置
  description?: string;
  channelIndex?: number; // 关联的通道索引
}

export interface MarkerPair {
  id: string;
  startMarker: Marker;
  endMarker: Marker;
  name: string;
  color: string;
  measurementType: 'time' | 'frequency' | 'pulse_width' | 'period' | 'custom';
  visible: boolean;
}

export interface MeasurementResult {
  id: string;
  type: 'time' | 'frequency' | 'pulse_width' | 'period' | 'samples';
  value: number;
  unit: string;
  displayText: string;
  startSample: number;
  endSample: number;
  sampleRate: number;
  accuracy: number; // 测量精度
}

export interface MarkerConfig {
  showLabels: boolean;
  showValues: boolean;
  labelFont: string;
  labelSize: number;
  markerWidth: number;
  snapToEdge: boolean; // 是否自动吸附到边沿
  snapTolerance: number; // 吸附容差
  enableDragging: boolean;
  showCrosshair: boolean;
}

export class MarkerTools {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private config: MarkerConfig;
  
  // 标记管理
  private markers: Map<string, Marker> = new Map();
  private markerPairs: Map<string, MarkerPair> = new Map();
  private nextMarkerId = 1;
  
  // 交互状态
  private draggedMarker: Marker | null = null;
  private dragOffset = { x: 0, y: 0 };
  private hoveredMarker: Marker | null = null;
  
  // 采样和时间信息
  private sampleRate = 1000000; // 默认1MHz
  private firstSample = 0;
  private visibleSamples = 1000;\n  private channels: AnalyzerChannel[] = [];\n  \n  // 事件监听器\n  private eventListeners: Map<string, ((data: any) => void)[]> = new Map();\n  \n  constructor(canvas: HTMLCanvasElement, config?: Partial<MarkerConfig>) {\n    this.canvas = canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('无法获取Canvas 2D上下文');\n    }\n    this.ctx = ctx;\n    \n    this.config = {\n      showLabels: true,\n      showValues: true,\n      labelFont: 'monospace',\n      labelSize: 12,\n      markerWidth: 2,\n      snapToEdge: true,\n      snapTolerance: 5, // 5个样本\n      enableDragging: true,\n      showCrosshair: true,\n      ...config\n    };\n    \n    this.setupEventListeners();\n  }\n  \n  /**\n   * 设置事件监听器\n   */\n  private setupEventListeners(): void {\n    this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));\n    this.canvas.addEventListener('dblclick', this.onDoubleClick.bind(this));\n    this.canvas.addEventListener('keydown', this.onKeyDown.bind(this));\n    \n    this.canvas.tabIndex = 0; // 允许接收键盘事件\n  }\n  \n  /**\n   * 设置采样信息\n   */\n  public setSampleInfo(\n    sampleRate: number,\n    firstSample: number,\n    visibleSamples: number,\n    channels: AnalyzerChannel[]\n  ): void {\n    this.sampleRate = sampleRate;\n    this.firstSample = firstSample;\n    this.visibleSamples = visibleSamples;\n    this.channels = channels;\n  }\n  \n  /**\n   * 添加标记\n   */\n  public addMarker(\n    sample: number,\n    type: Marker['type'] = 'user',\n    name?: string,\n    color?: string\n  ): Marker {\n    const id = `marker_${this.nextMarkerId++}`;\n    \n    // 自动吸附到边沿\n    if (this.config.snapToEdge && type === 'user') {\n      sample = this.snapToNearestEdge(sample);\n    }\n    \n    const marker: Marker = {\n      id,\n      name: name || `M${this.nextMarkerId - 1}`,\n      sample,\n      timestamp: sample / this.sampleRate,\n      color: color || this.getDefaultMarkerColor(type),\n      type,\n      visible: true,\n      locked: false\n    };\n    \n    this.markers.set(id, marker);\n    \n    this.emitEvent('markerAdded', { marker });\n    \n    return marker;\n  }\n  \n  /**\n   * 移除标记\n   */\n  public removeMarker(markerId: string): boolean {\n    const marker = this.markers.get(markerId);\n    if (marker) {\n      this.markers.delete(markerId);\n      \n      // 移除相关的标记对\n      for (const [pairId, pair] of this.markerPairs) {\n        if (pair.startMarker.id === markerId || pair.endMarker.id === markerId) {\n          this.markerPairs.delete(pairId);\n        }\n      }\n      \n      this.emitEvent('markerRemoved', { marker });\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * 获取所有标记\n   */\n  public getMarkers(): Marker[] {\n    return Array.from(this.markers.values());\n  }\n  \n  /**\n   * 获取指定类型的标记\n   */\n  public getMarkersByType(type: Marker['type']): Marker[] {\n    return Array.from(this.markers.values()).filter(m => m.type === type);\n  }\n  \n  /**\n   * 创建标记对用于测量\n   */\n  public createMarkerPair(\n    startSample: number,\n    endSample: number,\n    measurementType: MarkerPair['measurementType'] = 'time',\n    name?: string\n  ): MarkerPair {\n    const startMarker = this.addMarker(startSample, 'measurement', `${name || 'Measure'}_Start`);\n    const endMarker = this.addMarker(endSample, 'measurement', `${name || 'Measure'}_End`);\n    \n    const pairId = `pair_${Date.now()}`;\n    const pair: MarkerPair = {\n      id: pairId,\n      startMarker,\n      endMarker,\n      name: name || `Measurement ${this.markerPairs.size + 1}`,\n      color: '#ffff00',\n      measurementType,\n      visible: true\n    };\n    \n    this.markerPairs.set(pairId, pair);\n    \n    this.emitEvent('markerPairCreated', { pair });\n    \n    return pair;\n  }\n  \n  /**\n   * 移除标记对\n   */\n  public removeMarkerPair(pairId: string): boolean {\n    const pair = this.markerPairs.get(pairId);\n    if (pair) {\n      this.removeMarker(pair.startMarker.id);\n      this.removeMarker(pair.endMarker.id);\n      this.markerPairs.delete(pairId);\n      \n      this.emitEvent('markerPairRemoved', { pair });\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * 获取标记对\n   */\n  public getMarkerPairs(): MarkerPair[] {\n    return Array.from(this.markerPairs.values());\n  }\n  \n  /**\n   * 鼠标按下事件\n   */\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.config.enableDragging) return;\n    \n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // 检查是否点击了标记\n    const clickedMarker = this.getMarkerAtPosition(x, y);\n    \n    if (clickedMarker && !clickedMarker.locked) {\n      this.draggedMarker = clickedMarker;\n      this.dragOffset.x = x - this.sampleToPixel(clickedMarker.sample);\n      this.dragOffset.y = 0;\n      \n      this.canvas.style.cursor = 'grabbing';\n      event.preventDefault();\n    } else if (event.ctrlKey || event.metaKey) {\n      // Ctrl+点击添加新标记\n      const sample = this.pixelToSample(x);\n      this.addMarker(sample, 'user');\n    }\n  }\n  \n  /**\n   * 鼠标移动事件\n   */\n  private onMouseMove(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    if (this.draggedMarker) {\n      // 拖拽标记\n      const newSample = this.pixelToSample(x - this.dragOffset.x);\n      const clampedSample = Math.max(0, Math.min(newSample, this.getMaxSample()));\n      \n      // 自动吸附到边沿\n      const finalSample = this.config.snapToEdge ? \n        this.snapToNearestEdge(clampedSample) : clampedSample;\n      \n      this.draggedMarker.sample = finalSample;\n      this.draggedMarker.timestamp = finalSample / this.sampleRate;\n      \n      this.emitEvent('markerMoved', { marker: this.draggedMarker });\n    } else {\n      // 检查鼠标悬停\n      const hoveredMarker = this.getMarkerAtPosition(x, y);\n      \n      if (hoveredMarker !== this.hoveredMarker) {\n        this.hoveredMarker = hoveredMarker;\n        \n        if (hoveredMarker) {\n          this.canvas.style.cursor = 'grab';\n          this.showMarkerTooltip(hoveredMarker, event.clientX, event.clientY);\n        } else {\n          this.canvas.style.cursor = 'default';\n          this.hideMarkerTooltip();\n        }\n      }\n    }\n  }\n  \n  /**\n   * 鼠标抬起事件\n   */\n  private onMouseUp(event: MouseEvent): void {\n    if (this.draggedMarker) {\n      this.emitEvent('markerDragEnd', { marker: this.draggedMarker });\n      this.draggedMarker = null;\n      this.canvas.style.cursor = 'default';\n    }\n  }\n  \n  /**\n   * 双击事件\n   */\n  private onDoubleClick(event: MouseEvent): void {\n    const rect = this.canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    \n    const clickedMarker = this.getMarkerAtPosition(x, event.clientY - rect.top);\n    \n    if (clickedMarker) {\n      // 双击标记打开编辑对话框\n      this.emitEvent('markerEdit', { marker: clickedMarker });\n    }\n  }\n  \n  /**\n   * 键盘事件\n   */\n  private onKeyDown(event: KeyboardEvent): void {\n    if (this.hoveredMarker && !this.hoveredMarker.locked) {\n      switch (event.code) {\n        case 'Delete':\n        case 'Backspace':\n          this.removeMarker(this.hoveredMarker.id);\n          break;\n        case 'ArrowLeft':\n          this.moveMarker(this.hoveredMarker, -1);\n          break;\n        case 'ArrowRight':\n          this.moveMarker(this.hoveredMarker, 1);\n          break;\n      }\n    }\n  }\n  \n  /**\n   * 移动标记\n   */\n  private moveMarker(marker: Marker, deltaSamples: number): void {\n    const newSample = Math.max(0, Math.min(marker.sample + deltaSamples, this.getMaxSample()));\n    marker.sample = newSample;\n    marker.timestamp = newSample / this.sampleRate;\n    \n    this.emitEvent('markerMoved', { marker });\n  }\n  \n  /**\n   * 获取指定位置的标记\n   */\n  private getMarkerAtPosition(x: number, y: number): Marker | null {\n    const tolerance = 10; // 像素容差\n    \n    for (const marker of this.markers.values()) {\n      if (!marker.visible) continue;\n      \n      const markerX = this.sampleToPixel(marker.sample);\n      \n      if (Math.abs(x - markerX) <= tolerance) {\n        return marker;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * 样本转像素坐标\n   */\n  private sampleToPixel(sample: number): number {\n    const rect = this.canvas.getBoundingClientRect();\n    const sampleWidth = rect.width / this.visibleSamples;\n    return (sample - this.firstSample) * sampleWidth;\n  }\n  \n  /**\n   * 像素坐标转样本\n   */\n  private pixelToSample(x: number): number {\n    const rect = this.canvas.getBoundingClientRect();\n    const sampleWidth = rect.width / this.visibleSamples;\n    return this.firstSample + Math.round(x / sampleWidth);\n  }\n  \n  /**\n   * 获取最大样本数\n   */\n  private getMaxSample(): number {\n    if (this.channels.length > 0 && this.channels[0].samples) {\n      return this.channels[0].samples.length - 1;\n    }\n    return this.firstSample + this.visibleSamples;\n  }\n  \n  /**\n   * 吸附到最近的边沿\n   */\n  private snapToNearestEdge(sample: number): number {\n    const tolerance = this.config.snapTolerance;\n    let bestSample = sample;\n    let minDistance = tolerance + 1;\n    \n    // 检查所有通道的边沿\n    for (const channel of this.channels) {\n      if (!channel.samples || channel.hidden) continue;\n      \n      // 在样本附近查找边沿\n      const startIndex = Math.max(0, sample - tolerance);\n      const endIndex = Math.min(channel.samples.length - 1, sample + tolerance);\n      \n      for (let i = startIndex; i < endIndex; i++) {\n        if (i > 0 && channel.samples[i] !== channel.samples[i - 1]) {\n          const distance = Math.abs(i - sample);\n          if (distance < minDistance) {\n            minDistance = distance;\n            bestSample = i;\n          }\n        }\n      }\n    }\n    \n    return bestSample;\n  }\n  \n  /**\n   * 获取默认标记颜色\n   */\n  private getDefaultMarkerColor(type: Marker['type']): string {\n    const colors = {\n      user: '#00ffff',\n      trigger: '#ffffff',\n      burst: '#f0ffff',\n      cursor: '#ffff00',\n      measurement: '#ff8c00'\n    };\n    \n    return colors[type] || '#ffffff';\n  }\n  \n  /**\n   * 显示标记提示\n   */\n  private showMarkerTooltip(marker: Marker, x: number, y: number): void {\n    const tooltip = document.getElementById('marker-tooltip') || document.createElement('div');\n    tooltip.id = 'marker-tooltip';\n    tooltip.style.position = 'fixed';\n    tooltip.style.left = `${x + 10}px`;\n    tooltip.style.top = `${y - 10}px`;\n    tooltip.style.background = 'rgba(0, 0, 0, 0.8)';\n    tooltip.style.color = 'white';\n    tooltip.style.padding = '4px 8px';\n    tooltip.style.borderRadius = '4px';\n    tooltip.style.fontSize = '12px';\n    tooltip.style.fontFamily = 'monospace';\n    tooltip.style.zIndex = '1000';\n    tooltip.style.whiteSpace = 'nowrap';\n    \n    const timeText = this.formatTime(marker.timestamp);\n    const sampleText = `Sample: ${marker.sample}`;\n    \n    tooltip.innerHTML = `\n      <div style=\"color: ${marker.color}; font-weight: bold;\">${marker.name}</div>\n      <div>Time: ${timeText}</div>\n      <div>${sampleText}</div>\n    `;\n    \n    if (!tooltip.parentElement) {\n      document.body.appendChild(tooltip);\n    }\n  }\n  \n  /**\n   * 隐藏标记提示\n   */\n  private hideMarkerTooltip(): void {\n    const tooltip = document.getElementById('marker-tooltip');\n    if (tooltip) {\n      tooltip.remove();\n    }\n  }\n  \n  /**\n   * 格式化时间显示\n   */\n  private formatTime(seconds: number): string {\n    if (seconds < 1e-6) {\n      return `${(seconds * 1e9).toFixed(2)} ns`;\n    } else if (seconds < 1e-3) {\n      return `${(seconds * 1e6).toFixed(2)} µs`;\n    } else if (seconds < 1) {\n      return `${(seconds * 1e3).toFixed(2)} ms`;\n    } else {\n      return `${seconds.toFixed(3)} s`;\n    }\n  }\n  \n  /**\n   * 渲染所有标记\n   */\n  public renderMarkers(): void {\n    for (const marker of this.markers.values()) {\n      if (marker.visible) {\n        this.renderMarker(marker);\n      }\n    }\n    \n    // 渲染标记对的连接线\n    for (const pair of this.markerPairs.values()) {\n      if (pair.visible) {\n        this.renderMarkerPair(pair);\n      }\n    }\n  }\n  \n  /**\n   * 渲染单个标记\n   */\n  private renderMarker(marker: Marker): void {\n    const x = this.sampleToPixel(marker.sample);\n    const rect = this.canvas.getBoundingClientRect();\n    \n    // 检查标记是否在可见区域内\n    if (x < -10 || x > rect.width + 10) {\n      return;\n    }\n    \n    this.ctx.save();\n    \n    // 绘制标记线\n    this.ctx.strokeStyle = marker.color;\n    this.ctx.lineWidth = this.config.markerWidth;\n    this.ctx.setLineDash(marker.type === 'trigger' ? [] : [5, 3]);\n    \n    this.ctx.beginPath();\n    this.ctx.moveTo(x, 0);\n    this.ctx.lineTo(x, rect.height);\n    this.ctx.stroke();\n    \n    // 重置线条样式\n    this.ctx.setLineDash([]);\n    \n    // 绘制标签\n    if (this.config.showLabels) {\n      this.renderMarkerLabel(marker, x, 20);\n    }\n    \n    // 绘制时间值\n    if (this.config.showValues) {\n      const timeText = this.formatTime(marker.timestamp);\n      this.renderMarkerValue(timeText, x, 40, marker.color);\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 渲染标记标签\n   */\n  private renderMarkerLabel(marker: Marker, x: number, y: number): void {\n    this.ctx.font = `${this.config.labelSize}px ${this.config.labelFont}`;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    \n    // 绘制背景\n    const textMetrics = this.ctx.measureText(marker.name);\n    const padding = 4;\n    \n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n    this.ctx.fillRect(\n      x - textMetrics.width / 2 - padding,\n      y - this.config.labelSize / 2 - padding,\n      textMetrics.width + padding * 2,\n      this.config.labelSize + padding * 2\n    );\n    \n    // 绘制文字\n    this.ctx.fillStyle = marker.color;\n    this.ctx.fillText(marker.name, x, y);\n  }\n  \n  /**\n   * 渲染标记值\n   */\n  private renderMarkerValue(text: string, x: number, y: number, color: string): void {\n    this.ctx.font = `${this.config.labelSize - 2}px ${this.config.labelFont}`;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    \n    // 绘制背景\n    const textMetrics = this.ctx.measureText(text);\n    const padding = 2;\n    \n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n    this.ctx.fillRect(\n      x - textMetrics.width / 2 - padding,\n      y - (this.config.labelSize - 2) / 2 - padding,\n      textMetrics.width + padding * 2,\n      (this.config.labelSize - 2) + padding * 2\n    );\n    \n    // 绘制文字\n    this.ctx.fillStyle = color;\n    this.ctx.fillText(text, x, y);\n  }\n  \n  /**\n   * 渲染标记对\n   */\n  private renderMarkerPair(pair: MarkerPair): void {\n    const startX = this.sampleToPixel(pair.startMarker.sample);\n    const endX = this.sampleToPixel(pair.endMarker.sample);\n    const rect = this.canvas.getBoundingClientRect();\n    \n    // 绘制连接线\n    this.ctx.save();\n    this.ctx.strokeStyle = pair.color;\n    this.ctx.lineWidth = 1;\n    this.ctx.setLineDash([3, 3]);\n    \n    this.ctx.beginPath();\n    this.ctx.moveTo(startX, rect.height - 30);\n    this.ctx.lineTo(endX, rect.height - 30);\n    this.ctx.stroke();\n    \n    // 绘制测量结果\n    const measurement = this.calculateMeasurement(pair);\n    if (measurement) {\n      const centerX = (startX + endX) / 2;\n      this.renderMarkerValue(measurement.displayText, centerX, rect.height - 15, pair.color);\n    }\n    \n    this.ctx.restore();\n  }\n  \n  /**\n   * 计算测量结果\n   */\n  private calculateMeasurement(pair: MarkerPair): MeasurementResult | null {\n    const startSample = Math.min(pair.startMarker.sample, pair.endMarker.sample);\n    const endSample = Math.max(pair.startMarker.sample, pair.endMarker.sample);\n    const sampleDiff = endSample - startSample;\n    \n    if (sampleDiff === 0) return null;\n    \n    const timeDiff = sampleDiff / this.sampleRate;\n    \n    let result: MeasurementResult;\n    \n    switch (pair.measurementType) {\n      case 'time':\n        result = {\n          id: pair.id,\n          type: 'time',\n          value: timeDiff,\n          unit: 's',\n          displayText: this.formatTime(timeDiff),\n          startSample,\n          endSample,\n          sampleRate: this.sampleRate,\n          accuracy: 1 / this.sampleRate\n        };\n        break;\n        \n      case 'frequency':\n        const frequency = 1 / timeDiff;\n        result = {\n          id: pair.id,\n          type: 'frequency',\n          value: frequency,\n          unit: 'Hz',\n          displayText: this.formatFrequency(frequency),\n          startSample,\n          endSample,\n          sampleRate: this.sampleRate,\n          accuracy: 1 / (timeDiff * timeDiff * this.sampleRate)\n        };\n        break;\n        \n      case 'samples':\n        result = {\n          id: pair.id,\n          type: 'samples',\n          value: sampleDiff,\n          unit: 'samples',\n          displayText: `${sampleDiff} samples`,\n          startSample,\n          endSample,\n          sampleRate: this.sampleRate,\n          accuracy: 1\n        };\n        break;\n        \n      default:\n        return null;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * 格式化频率显示\n   */\n  private formatFrequency(frequency: number): string {\n    if (frequency < 1000) {\n      return `${frequency.toFixed(2)} Hz`;\n    } else if (frequency < 1000000) {\n      return `${(frequency / 1000).toFixed(2)} kHz`;\n    } else {\n      return `${(frequency / 1000000).toFixed(2)} MHz`;\n    }\n  }\n  \n  /**\n   * 添加事件监听器\n   */\n  public addEventListener(type: string, listener: (data: any) => void): void {\n    if (!this.eventListeners.has(type)) {\n      this.eventListeners.set(type, []);\n    }\n    this.eventListeners.get(type)!.push(listener);\n  }\n  \n  /**\n   * 移除事件监听器\n   */\n  public removeEventListener(type: string, listener: (data: any) => void): void {\n    const listeners = this.eventListeners.get(type);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n  \n  /**\n   * 发出事件\n   */\n  private emitEvent(type: string, data: any): void {\n    const listeners = this.eventListeners.get(type);\n    if (listeners) {\n      listeners.forEach(listener => listener(data));\n    }\n  }\n  \n  /**\n   * 更新配置\n   */\n  public updateConfig(config: Partial<MarkerConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n  \n  /**\n   * 清除所有标记\n   */\n  public clearAllMarkers(): void {\n    this.markers.clear();\n    this.markerPairs.clear();\n    this.nextMarkerId = 1;\n    \n    this.emitEvent('allMarkersCleared', {});\n  }\n  \n  /**\n   * 导出标记数据\n   */\n  public exportMarkers(): any {\n    return {\n      markers: Array.from(this.markers.values()),\n      markerPairs: Array.from(this.markerPairs.values()),\n      config: this.config\n    };\n  }\n  \n  /**\n   * 导入标记数据\n   */\n  public importMarkers(data: any): void {\n    if (data.markers) {\n      this.markers.clear();\n      data.markers.forEach((marker: Marker) => {\n        this.markers.set(marker.id, marker);\n        this.nextMarkerId = Math.max(this.nextMarkerId, parseInt(marker.id.split('_')[1]) + 1);\n      });\n    }\n    \n    if (data.markerPairs) {\n      this.markerPairs.clear();\n      data.markerPairs.forEach((pair: MarkerPair) => {\n        this.markerPairs.set(pair.id, pair);\n      });\n    }\n    \n    if (data.config) {\n      this.config = { ...this.config, ...data.config };\n    }\n  }\n  \n  /**\n   * 清理资源\n   */\n  public dispose(): void {\n    // 移除事件监听器\n    this.canvas.removeEventListener('mousedown', this.onMouseDown.bind(this));\n    this.canvas.removeEventListener('mousemove', this.onMouseMove.bind(this));\n    this.canvas.removeEventListener('mouseup', this.onMouseUp.bind(this));\n    this.canvas.removeEventListener('dblclick', this.onDoubleClick.bind(this));\n    this.canvas.removeEventListener('keydown', this.onKeyDown.bind(this));\n    \n    // 清理数据\n    this.markers.clear();\n    this.markerPairs.clear();\n    this.eventListeners.clear();\n    \n    // 清理tooltip\n    this.hideMarkerTooltip();\n  }\n}"