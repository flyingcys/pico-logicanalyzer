/**
 * 测量工具 - 基于原版的MeasureDialog功能
 * 提供脉冲宽度、频率、占空比等高级测量功能
 */

import { AnalyzerChannel } from '../../models/CaptureModels';

export interface PulseInfo {
  startSample: number;
  endSample: number;
  width: number; // 脉冲宽度（秒）
  level: boolean; // 高电平(true)或低电平(false)
  channelIndex: number;
}

export interface FrequencyMeasurement {
  frequency: number; // Hz
  period: number; // 秒
  accuracy: number; // 测量精度
  sampleCount: number; // 用于测量的样本数
  confidence: number; // 置信度 (0-1)
}

export interface DutyCycleMeasurement {
  dutyCycle: number; // 占空比 (0-1)
  highTime: number; // 高电平时间（秒）
  lowTime: number; // 低电平时间（秒）
  period: number; // 周期（秒）
  frequency: number; // 频率 (Hz)
}

export interface EdgeMeasurement {
  type: 'rising' | 'falling';
  startSample: number;
  endSample: number;
  riseTime?: number; // 上升时间（秒）
  fallTime?: number; // 下降时间（秒）
  amplitude?: number; // 幅度
}

export interface StatisticalMeasurement {
  min: number;
  max: number;
  mean: number;
  rms: number;
  standardDeviation: number;
  sampleCount: number;
}

export interface MeasurementConfig {
  edgeThreshold: number; // 边沿检测阈值 (0-1)
  minimumPulseWidth: number; // 最小脉冲宽度（样本数）
  maximumPulseWidth: number; // 最大脉冲宽度（样本数）
  hysteresis: number; // 滞后量（样本数）
  autoRange: boolean; // 自动范围选择
  statisticalSamples: number; // 统计测量的样本数
}

export class MeasurementTools {
  private config: MeasurementConfig;
  private sampleRate = 1000000; // 默认1MHz
  private channels: AnalyzerChannel[] = [];
  
  constructor(config?: Partial<MeasurementConfig>) {
    this.config = {
      edgeThreshold: 0.5,
      minimumPulseWidth: 2,
      maximumPulseWidth: 1000000,
      hysteresis: 1,
      autoRange: true,
      statisticalSamples: 10000,
      ...config
    };
  }
  
  /**
   * 设置采样信息
   */\n  public setSampleInfo(sampleRate: number, channels: AnalyzerChannel[]): void {\n    this.sampleRate = sampleRate;\n    this.channels = channels;\n  }\n  \n  /**\n   * 检测边沿 - 基于原版的边沿检测逻辑\n   */\n  public detectEdges(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number,\n    edgeType: 'rising' | 'falling' | 'both' = 'both'\n  ): EdgeMeasurement[] {\n    if (channelIndex >= this.channels.length) {\n      throw new Error(`Channel ${channelIndex} not found`);\n    }\n    \n    const channel = this.channels[channelIndex];\n    if (!channel.samples) {\n      return [];\n    }\n    \n    const samples = channel.samples;\n    const actualEndSample = endSample || samples.length;\n    const edges: EdgeMeasurement[] = [];\n    \n    let lastValue = samples[startSample];\n    \n    for (let i = startSample + 1; i < actualEndSample; i++) {\n      const currentValue = samples[i];\n      \n      // 检测上升沿\n      if (currentValue > lastValue && (edgeType === 'rising' || edgeType === 'both')) {\n        edges.push({\n          type: 'rising',\n          startSample: i - 1,\n          endSample: i\n        });\n      }\n      \n      // 检测下降沿\n      if (currentValue < lastValue && (edgeType === 'falling' || edgeType === 'both')) {\n        edges.push({\n          type: 'falling',\n          startSample: i - 1,\n          endSample: i\n        });\n      }\n      \n      lastValue = currentValue;\n    }\n    \n    return edges;\n  }\n  \n  /**\n   * 检测脉冲 - 基于原版的脉冲检测算法\n   */\n  public detectPulses(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number,\n    pulseLevel: boolean = true\n  ): PulseInfo[] {\n    if (channelIndex >= this.channels.length) {\n      throw new Error(`Channel ${channelIndex} not found`);\n    }\n    \n    const channel = this.channels[channelIndex];\n    if (!channel.samples) {\n      return [];\n    }\n    \n    const samples = channel.samples;\n    const actualEndSample = endSample || samples.length;\n    const pulses: PulseInfo[] = [];\n    \n    let pulseStart = -1;\n    let inPulse = false;\n    \n    for (let i = startSample; i < actualEndSample; i++) {\n      const currentLevel = samples[i] !== 0;\n      \n      if (!inPulse && currentLevel === pulseLevel) {\n        // 脉冲开始\n        pulseStart = i;\n        inPulse = true;\n      } else if (inPulse && currentLevel !== pulseLevel) {\n        // 脉冲结束\n        const pulseWidth = (i - pulseStart) / this.sampleRate;\n        const pulseWidthSamples = i - pulseStart;\n        \n        // 检查脉冲宽度是否在有效范围内\n        if (pulseWidthSamples >= this.config.minimumPulseWidth &&\n            pulseWidthSamples <= this.config.maximumPulseWidth) {\n          \n          pulses.push({\n            startSample: pulseStart,\n            endSample: i,\n            width: pulseWidth,\n            level: pulseLevel,\n            channelIndex\n          });\n        }\n        \n        inPulse = false;\n      }\n    }\n    \n    // 处理在采样结束时仍在进行的脉冲\n    if (inPulse && pulseStart !== -1) {\n      const pulseWidth = (actualEndSample - pulseStart) / this.sampleRate;\n      const pulseWidthSamples = actualEndSample - pulseStart;\n      \n      if (pulseWidthSamples >= this.config.minimumPulseWidth &&\n          pulseWidthSamples <= this.config.maximumPulseWidth) {\n        \n        pulses.push({\n          startSample: pulseStart,\n          endSample: actualEndSample,\n          width: pulseWidth,\n          level: pulseLevel,\n          channelIndex\n        });\n      }\n    }\n    \n    return pulses;\n  }\n  \n  /**\n   * 测量频率 - 基于周期检测\n   */\n  public measureFrequency(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number,\n    method: 'period' | 'zero_crossing' | 'autocorrelation' = 'period'\n  ): FrequencyMeasurement | null {\n    switch (method) {\n      case 'period':\n        return this.measureFrequencyByPeriod(channelIndex, startSample, endSample);\n      case 'zero_crossing':\n        return this.measureFrequencyByZeroCrossing(channelIndex, startSample, endSample);\n      case 'autocorrelation':\n        return this.measureFrequencyByAutocorrelation(channelIndex, startSample, endSample);\n      default:\n        return null;\n    }\n  }\n  \n  /**\n   * 通过周期测量频率\n   */\n  private measureFrequencyByPeriod(\n    channelIndex: number,\n    startSample: number,\n    endSample?: number\n  ): FrequencyMeasurement | null {\n    const edges = this.detectEdges(channelIndex, startSample, endSample, 'rising');\n    \n    if (edges.length < 2) {\n      return null;\n    }\n    \n    // 计算多个周期的平均值以提高精度\n    const periods: number[] = [];\n    \n    for (let i = 1; i < edges.length; i++) {\n      const periodSamples = edges[i].startSample - edges[i - 1].startSample;\n      const period = periodSamples / this.sampleRate;\n      periods.push(period);\n    }\n    \n    if (periods.length === 0) {\n      return null;\n    }\n    \n    // 计算平均周期\n    const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length;\n    const frequency = 1 / avgPeriod;\n    \n    // 计算标准差来评估精度\n    const variance = periods.reduce((sum, p) => sum + Math.pow(p - avgPeriod, 2), 0) / periods.length;\n    const stdDev = Math.sqrt(variance);\n    const accuracy = stdDev / avgPeriod; // 相对误差\n    \n    // 计算置信度（基于测量的周期数和一致性）\n    const confidence = Math.min(0.95, Math.max(0.1, periods.length / 10 * (1 - accuracy)));\n    \n    return {\n      frequency,\n      period: avgPeriod,\n      accuracy,\n      sampleCount: edges.length,\n      confidence\n    };\n  }\n  \n  /**\n   * 通过零点交叉测量频率\n   */\n  private measureFrequencyByZeroCrossing(\n    channelIndex: number,\n    startSample: number,\n    endSample?: number\n  ): FrequencyMeasurement | null {\n    // 数字信号的零点交叉相当于电平变化\n    const edges = this.detectEdges(channelIndex, startSample, endSample, 'both');\n    \n    if (edges.length < 4) { // 至少需要2个完整周期\n      return null;\n    }\n    \n    const totalSamples = edges[edges.length - 1].startSample - edges[0].startSample;\n    const totalTime = totalSamples / this.sampleRate;\n    const cycles = edges.length / 2; // 每个周期包含2个边沿\n    \n    const frequency = cycles / totalTime;\n    const period = 1 / frequency;\n    \n    // 精度基于采样率和测量时长\n    const accuracy = 1 / (this.sampleRate * totalTime);\n    const confidence = Math.min(0.9, cycles / 5); // 基于周期数\n    \n    return {\n      frequency,\n      period,\n      accuracy,\n      sampleCount: edges.length,\n      confidence\n    };\n  }\n  \n  /**\n   * 通过自相关测量频率\n   */\n  private measureFrequencyByAutocorrelation(\n    channelIndex: number,\n    startSample: number,\n    endSample?: number\n  ): FrequencyMeasurement | null {\n    if (channelIndex >= this.channels.length) {\n      return null;\n    }\n    \n    const channel = this.channels[channelIndex];\n    if (!channel.samples) {\n      return null;\n    }\n    \n    const samples = channel.samples;\n    const actualEndSample = endSample || samples.length;\n    const dataLength = actualEndSample - startSample;\n    \n    if (dataLength < 100) {\n      return null;\n    }\n    \n    // 限制计算范围以提高性能\n    const maxLag = Math.min(dataLength / 2, 1000);\n    const autocorr: number[] = [];\n    \n    // 计算自相关函数\n    for (let lag = 1; lag < maxLag; lag++) {\n      let sum = 0;\n      let count = 0;\n      \n      for (let i = startSample; i < actualEndSample - lag; i++) {\n        sum += samples[i] * samples[i + lag];\n        count++;\n      }\n      \n      autocorr[lag] = count > 0 ? sum / count : 0;\n    }\n    \n    // 找到第一个峰值（跳过lag=0）\n    let maxCorr = 0;\n    let bestLag = 0;\n    \n    for (let lag = 10; lag < autocorr.length - 1; lag++) {\n      if (autocorr[lag] > maxCorr && \n          autocorr[lag] > autocorr[lag - 1] && \n          autocorr[lag] > autocorr[lag + 1]) {\n        maxCorr = autocorr[lag];\n        bestLag = lag;\n        break;\n      }\n    }\n    \n    if (bestLag === 0) {\n      return null;\n    }\n    \n    const period = bestLag / this.sampleRate;\n    const frequency = 1 / period;\n    \n    // 精度评估基于相关性强度\n    const accuracy = (1 - maxCorr) * 0.1; // 相关性越强，精度越高\n    const confidence = Math.min(0.85, maxCorr);\n    \n    return {\n      frequency,\n      period,\n      accuracy,\n      sampleCount: dataLength,\n      confidence\n    };\n  }\n  \n  /**\n   * 测量占空比\n   */\n  public measureDutyCycle(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number,\n    numberOfCycles: number = 10\n  ): DutyCycleMeasurement | null {\n    const highPulses = this.detectPulses(channelIndex, startSample, endSample, true);\n    const lowPulses = this.detectPulses(channelIndex, startSample, endSample, false);\n    \n    if (highPulses.length === 0 || lowPulses.length === 0) {\n      return null;\n    }\n    \n    // 取指定数量的周期进行测量\n    const cyclesToMeasure = Math.min(numberOfCycles, Math.min(highPulses.length, lowPulses.length));\n    \n    let totalHighTime = 0;\n    let totalLowTime = 0;\n    \n    for (let i = 0; i < cyclesToMeasure; i++) {\n      totalHighTime += highPulses[i].width;\n      totalLowTime += lowPulses[i].width;\n    }\n    \n    const avgHighTime = totalHighTime / cyclesToMeasure;\n    const avgLowTime = totalLowTime / cyclesToMeasure;\n    const period = avgHighTime + avgLowTime;\n    const dutyCycle = avgHighTime / period;\n    const frequency = 1 / period;\n    \n    return {\n      dutyCycle,\n      highTime: avgHighTime,\n      lowTime: avgLowTime,\n      period,\n      frequency\n    };\n  }\n  \n  /**\n   * 测量脉冲宽度统计信息\n   */\n  public measurePulseStatistics(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number,\n    pulseLevel: boolean = true\n  ): StatisticalMeasurement | null {\n    const pulses = this.detectPulses(channelIndex, startSample, endSample, pulseLevel);\n    \n    if (pulses.length === 0) {\n      return null;\n    }\n    \n    const widths = pulses.map(p => p.width);\n    \n    // 计算统计信息\n    const min = Math.min(...widths);\n    const max = Math.max(...widths);\n    const mean = widths.reduce((sum, w) => sum + w, 0) / widths.length;\n    \n    // 计算RMS\n    const rms = Math.sqrt(widths.reduce((sum, w) => sum + w * w, 0) / widths.length);\n    \n    // 计算标准差\n    const variance = widths.reduce((sum, w) => sum + Math.pow(w - mean, 2), 0) / widths.length;\n    const standardDeviation = Math.sqrt(variance);\n    \n    return {\n      min,\n      max,\n      mean,\n      rms,\n      standardDeviation,\n      sampleCount: widths.length\n    };\n  }\n  \n  /**\n   * 测量信号完整性参数\n   */\n  public measureSignalIntegrity(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number\n  ): any {\n    const edges = this.detectEdges(channelIndex, startSample, endSample, 'both');\n    \n    if (edges.length === 0) {\n      return null;\n    }\n    \n    // 计算抖动（Jitter）\n    let jitter = 0;\n    if (edges.length > 2) {\n      const periods: number[] = [];\n      \n      for (let i = 2; i < edges.length; i += 2) {\n        const period = (edges[i].startSample - edges[i - 2].startSample) / this.sampleRate;\n        periods.push(period);\n      }\n      \n      if (periods.length > 1) {\n        const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length;\n        const periodVariance = periods.reduce((sum, p) => sum + Math.pow(p - avgPeriod, 2), 0) / periods.length;\n        jitter = Math.sqrt(periodVariance);\n      }\n    }\n    \n    // 计算信号转换时间（简化版）\n    const avgTransitionTime = 1 / this.sampleRate; // 受采样率限制\n    \n    return {\n      jitter,\n      transitionTime: avgTransitionTime,\n      edgeCount: edges.length,\n      signalActivity: edges.length / ((endSample || this.channels[channelIndex].samples!.length) - startSample)\n    };\n  }\n  \n  /**\n   * 自动测量 - 基于信号特征自动选择测量类型\n   */\n  public autoMeasure(\n    channelIndex: number,\n    startSample: number = 0,\n    endSample?: number\n  ): any {\n    const edges = this.detectEdges(channelIndex, startSample, endSample, 'both');\n    const highPulses = this.detectPulses(channelIndex, startSample, endSample, true);\n    const lowPulses = this.detectPulses(channelIndex, startSample, endSample, false);\n    \n    const results: any = {\n      edges: edges.length,\n      highPulses: highPulses.length,\n      lowPulses: lowPulses.length\n    };\n    \n    // 如果有足够的边沿，尝试频率测量\n    if (edges.length >= 4) {\n      const frequency = this.measureFrequency(channelIndex, startSample, endSample);\n      if (frequency && frequency.confidence > 0.5) {\n        results.frequency = frequency;\n      }\n    }\n    \n    // 如果有规律的脉冲，测量占空比\n    if (highPulses.length >= 2 && lowPulses.length >= 2) {\n      const dutyCycle = this.measureDutyCycle(channelIndex, startSample, endSample);\n      if (dutyCycle) {\n        results.dutyCycle = dutyCycle;\n      }\n    }\n    \n    // 脉冲统计\n    if (highPulses.length > 0) {\n      results.highPulseStats = this.measurePulseStatistics(channelIndex, startSample, endSample, true);\n    }\n    \n    if (lowPulses.length > 0) {\n      results.lowPulseStats = this.measurePulseStatistics(channelIndex, startSample, endSample, false);\n    }\n    \n    // 信号完整性\n    if (edges.length > 2) {\n      results.signalIntegrity = this.measureSignalIntegrity(channelIndex, startSample, endSample);\n    }\n    \n    return results;\n  }\n  \n  /**\n   * 格式化测量结果为可读文本\n   */\n  public formatMeasurementResults(results: any): string[] {\n    const lines: string[] = [];\n    \n    if (results.frequency) {\n      const freq = results.frequency;\n      lines.push(`Frequency: ${this.formatFrequency(freq.frequency)}`);\n      lines.push(`Period: ${this.formatTime(freq.period)}`);\n      lines.push(`Confidence: ${(freq.confidence * 100).toFixed(1)}%`);\n    }\n    \n    if (results.dutyCycle) {\n      const dc = results.dutyCycle;\n      lines.push(`Duty Cycle: ${(dc.dutyCycle * 100).toFixed(2)}%`);\n      lines.push(`High Time: ${this.formatTime(dc.highTime)}`);\n      lines.push(`Low Time: ${this.formatTime(dc.lowTime)}`);\n    }\n    \n    if (results.highPulseStats) {\n      const stats = results.highPulseStats;\n      lines.push(`High Pulse Stats:`);\n      lines.push(`  Count: ${stats.sampleCount}`);\n      lines.push(`  Min: ${this.formatTime(stats.min)}`);\n      lines.push(`  Max: ${this.formatTime(stats.max)}`);\n      lines.push(`  Mean: ${this.formatTime(stats.mean)}`);\n      lines.push(`  Std Dev: ${this.formatTime(stats.standardDeviation)}`);\n    }\n    \n    if (results.signalIntegrity) {\n      const si = results.signalIntegrity;\n      lines.push(`Signal Integrity:`);\n      lines.push(`  Jitter: ${this.formatTime(si.jitter)}`);\n      lines.push(`  Edge Count: ${si.edgeCount}`);\n      lines.push(`  Activity: ${(si.signalActivity * 100).toFixed(2)}%`);\n    }\n    \n    return lines;\n  }\n  \n  /**\n   * 格式化时间显示\n   */\n  private formatTime(seconds: number): string {\n    if (seconds < 1e-9) {\n      return `${(seconds * 1e12).toFixed(2)} ps`;\n    } else if (seconds < 1e-6) {\n      return `${(seconds * 1e9).toFixed(2)} ns`;\n    } else if (seconds < 1e-3) {\n      return `${(seconds * 1e6).toFixed(2)} µs`;\n    } else if (seconds < 1) {\n      return `${(seconds * 1e3).toFixed(2)} ms`;\n    } else {\n      return `${seconds.toFixed(3)} s`;\n    }\n  }\n  \n  /**\n   * 格式化频率显示\n   */\n  private formatFrequency(frequency: number): string {\n    if (frequency < 1000) {\n      return `${frequency.toFixed(2)} Hz`;\n    } else if (frequency < 1000000) {\n      return `${(frequency / 1000).toFixed(2)} kHz`;\n    } else if (frequency < 1000000000) {\n      return `${(frequency / 1000000).toFixed(2)} MHz`;\n    } else {\n      return `${(frequency / 1000000000).toFixed(2)} GHz`;\n    }\n  }\n  \n  /**\n   * 更新配置\n   */\n  public updateConfig(config: Partial<MeasurementConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n  \n  /**\n   * 获取配置\n   */\n  public getConfig(): MeasurementConfig {\n    return { ...this.config };\n  }\n}"