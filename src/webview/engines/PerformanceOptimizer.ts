/**
 * 性能优化器
 * 实现LOD、异步渲染、帧率控制等性能优化功能
 */

export interface PerformanceConfig {
  // 帧率控制
  targetFrameRate: number; // 目标帧率 (fps)
  maxFrameTime: number; // 最大帧时间 (ms)
  adaptiveFrameRate: boolean; // 自适应帧率\n  \n  // LOD控制\n  enableLOD: boolean; // 启用LOD\n  lodThresholds: number[]; // LOD阈值\n  lodStrategies: string[]; // LOD策略\n  \n  // 异步渲染\n  enableAsyncRender: boolean; // 启用异步渲染\n  maxConcurrentTasks: number; // 最大并发任务数\n  taskTimeSlice: number; // 任务时间片 (ms)\n  \n  // 内存管理\n  maxMemoryUsage: number; // 最大内存使用 (MB)\n  enableGarbageCollection: boolean; // 启用垃圾回收\n  gcInterval: number; // GC间隔 (ms)\n  \n  // 缓存控制\n  enableRenderCache: boolean; // 启用渲染缓存\n  cacheSize: number; // 缓存大小 (MB)\n  cacheStrategy: 'lru' | 'lfu' | 'adaptive'; // 缓存策略\n}\n\nexport interface PerformanceMetrics {\n  // 帧率指标\n  currentFPS: number;\n  averageFPS: number;\n  frameTime: number;\n  frameTimeHistory: number[];\n  \n  // 渲染指标\n  renderTime: number;\n  updateTime: number;\n  drawCalls: number;\n  \n  // 内存指标\n  memoryUsage: number;\n  cacheHitRate: number;\n  gcCount: number;\n  \n  // LOD指标\n  currentLOD: number;\n  lodSwitches: number;\n  qualityScore: number;\n}\n\nexport interface RenderTask {\n  id: string;\n  priority: number;\n  estimatedTime: number;\n  deadline: number;\n  execute: () => Promise<void>;\n  onComplete?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport class PerformanceOptimizer {\n  private config: PerformanceConfig;\n  private metrics: PerformanceMetrics;\n  \n  // 帧率控制\n  private lastFrameTime = 0;\n  private frameTimeHistory: number[] = [];\n  private frameCount = 0;\n  private fpsUpdateTime = 0;\n  \n  // 任务调度\n  private taskQueue: RenderTask[] = [];\n  private runningTasks: Map<string, Promise<void>> = new Map();\n  private isScheduling = false;\n  \n  // LOD管理\n  private currentLOD = 0;\n  private lodHistory: number[] = [];\n  private qualityScore = 1.0;\n  \n  // 内存管理\n  private memoryUsage = 0;\n  private lastGCTime = 0;\n  private gcCount = 0;\n  \n  // 缓存管理\n  private renderCache: Map<string, any> = new Map();\n  private cacheHits = 0;\n  private cacheMisses = 0;\n  \n  // 性能监控\n  private performanceObserver: PerformanceObserver | null = null;\n  \n  constructor(config?: Partial<PerformanceConfig>) {\n    this.config = {\n      targetFrameRate: 60,\n      maxFrameTime: 16.67, // 60fps\n      adaptiveFrameRate: true,\n      enableLOD: true,\n      lodThresholds: [16.67, 33.33, 50, 100], // ms\n      lodStrategies: ['full', 'downsample', 'minmax', 'skip'],\n      enableAsyncRender: true,\n      maxConcurrentTasks: 4,\n      taskTimeSlice: 5,\n      maxMemoryUsage: 512, // MB\n      enableGarbageCollection: true,\n      gcInterval: 30000, // 30s\n      enableRenderCache: true,\n      cacheSize: 100, // MB\n      cacheStrategy: 'lru',\n      ...config\n    };\n    \n    this.metrics = {\n      currentFPS: 0,\n      averageFPS: 0,\n      frameTime: 0,\n      frameTimeHistory: [],\n      renderTime: 0,\n      updateTime: 0,\n      drawCalls: 0,\n      memoryUsage: 0,\n      cacheHitRate: 0,\n      gcCount: 0,\n      currentLOD: 0,\n      lodSwitches: 0,\n      qualityScore: 1.0\n    };\n    \n    this.setupPerformanceMonitoring();\n    this.startGarbageCollection();\n  }\n  \n  /**\n   * 设置性能监控\n   */\n  private setupPerformanceMonitoring(): void {\n    if (typeof PerformanceObserver !== 'undefined') {\n      try {\n        this.performanceObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          for (const entry of entries) {\n            if (entry.entryType === 'measure') {\n              this.updatePerformanceMetrics(entry);\n            }\n          }\n        });\n        \n        this.performanceObserver.observe({ entryTypes: ['measure'] });\n      } catch (error) {\n        console.warn('Performance Observer not supported:', error);\n      }\n    }\n  }\n  \n  /**\n   * 开始帧测量\n   */\n  public startFrame(): void {\n    if (typeof performance !== 'undefined' && performance.mark) {\n      performance.mark('frame-start');\n    }\n    this.lastFrameTime = performance.now();\n  }\n  \n  /**\n   * 结束帧测量\n   */\n  public endFrame(): void {\n    const currentTime = performance.now();\n    const frameTime = currentTime - this.lastFrameTime;\n    \n    if (typeof performance !== 'undefined' && performance.measure) {\n      try {\n        performance.measure('frame-duration', 'frame-start');\n      } catch (error) {\n        // Ignore measurement errors\n      }\n    }\n    \n    this.updateFrameMetrics(frameTime);\n    this.adaptPerformance(frameTime);\n    \n    this.frameCount++;\n  }\n  \n  /**\n   * 更新帧指标\n   */\n  private updateFrameMetrics(frameTime: number): void {\n    this.metrics.frameTime = frameTime;\n    this.frameTimeHistory.push(frameTime);\n    \n    // 保持历史记录在合理范围内\n    if (this.frameTimeHistory.length > 60) {\n      this.frameTimeHistory.shift();\n    }\n    \n    // 更新FPS\n    const currentTime = performance.now();\n    if (currentTime - this.fpsUpdateTime >= 1000) {\n      const fps = this.frameCount * 1000 / (currentTime - this.fpsUpdateTime);\n      this.metrics.currentFPS = fps;\n      \n      // 计算平均FPS\n      if (this.frameTimeHistory.length > 0) {\n        const avgFrameTime = this.frameTimeHistory.reduce((sum, t) => sum + t, 0) / this.frameTimeHistory.length;\n        this.metrics.averageFPS = 1000 / avgFrameTime;\n      }\n      \n      this.frameCount = 0;\n      this.fpsUpdateTime = currentTime;\n    }\n    \n    this.metrics.frameTimeHistory = [...this.frameTimeHistory];\n  }\n  \n  /**\n   * 自适应性能调整\n   */\n  private adaptPerformance(frameTime: number): void {\n    if (!this.config.adaptiveFrameRate) return;\n    \n    // 计算性能压力\n    const targetFrameTime = 1000 / this.config.targetFrameRate;\n    const performancePressure = frameTime / targetFrameTime;\n    \n    // 调整LOD级别\n    if (this.config.enableLOD) {\n      this.adjustLOD(performancePressure);\n    }\n    \n    // 调整质量分数\n    this.updateQualityScore(performancePressure);\n    \n    // 如果性能压力过大，触发优化\n    if (performancePressure > 1.5) {\n      this.triggerOptimization();\n    }\n  }\n  \n  /**\n   * 调整LOD级别\n   */\n  private adjustLOD(performancePressure: number): void {\n    let newLOD = this.currentLOD;\n    \n    if (performancePressure > 1.2 && this.currentLOD < this.config.lodThresholds.length - 1) {\n      // 性能压力大，降低质量\n      newLOD = this.currentLOD + 1;\n    } else if (performancePressure < 0.8 && this.currentLOD > 0) {\n      // 性能充足，提高质量\n      newLOD = this.currentLOD - 1;\n    }\n    \n    if (newLOD !== this.currentLOD) {\n      this.currentLOD = newLOD;\n      this.metrics.currentLOD = newLOD;\n      this.metrics.lodSwitches++;\n      \n      this.lodHistory.push(newLOD);\n      if (this.lodHistory.length > 30) {\n        this.lodHistory.shift();\n      }\n    }\n  }\n  \n  /**\n   * 更新质量分数\n   */\n  private updateQualityScore(performancePressure: number): void {\n    // 质量分数基于LOD级别和性能压力\n    const lodPenalty = this.currentLOD * 0.2;\n    const pressurePenalty = Math.max(0, (performancePressure - 1) * 0.3);\n    \n    this.qualityScore = Math.max(0.1, 1.0 - lodPenalty - pressurePenalty);\n    this.metrics.qualityScore = this.qualityScore;\n  }\n  \n  /**\n   * 触发优化\n   */\n  private triggerOptimization(): void {\n    // 清理缓存\n    if (this.renderCache.size > 1000) {\n      this.cleanupCache();\n    }\n    \n    // 强制垃圾回收（如果可用）\n    if (this.config.enableGarbageCollection && typeof window !== 'undefined' && (window as any).gc) {\n      try {\n        (window as any).gc();\n        this.gcCount++;\n        this.metrics.gcCount = this.gcCount;\n      } catch (error) {\n        // Ignore GC errors\n      }\n    }\n  }\n  \n  /**\n   * 添加渲染任务\n   */\n  public addTask(task: RenderTask): void {\n    // 根据优先级插入任务\n    let insertIndex = this.taskQueue.length;\n    for (let i = 0; i < this.taskQueue.length; i++) {\n      if (this.taskQueue[i].priority < task.priority) {\n        insertIndex = i;\n        break;\n      }\n    }\n    \n    this.taskQueue.splice(insertIndex, 0, task);\n    \n    // 启动任务调度\n    if (!this.isScheduling) {\n      this.scheduleNextTask();\n    }\n  }\n  \n  /**\n   * 调度下一个任务\n   */\n  private async scheduleNextTask(): Promise<void> {\n    if (this.isScheduling || this.taskQueue.length === 0) {\n      return;\n    }\n    \n    this.isScheduling = true;\n    \n    while (this.taskQueue.length > 0 && this.runningTasks.size < this.config.maxConcurrentTasks) {\n      const task = this.taskQueue.shift()!;\n      \n      // 检查任务是否过期\n      if (performance.now() > task.deadline) {\n        continue;\n      }\n      \n      // 执行任务\n      const taskPromise = this.executeTask(task);\n      this.runningTasks.set(task.id, taskPromise);\n      \n      // 清理完成的任务\n      taskPromise.finally(() => {\n        this.runningTasks.delete(task.id);\n      });\n    }\n    \n    this.isScheduling = false;\n    \n    // 如果还有任务，等待一个时间片后继续\n    if (this.taskQueue.length > 0) {\n      setTimeout(() => this.scheduleNextTask(), this.config.taskTimeSlice);\n    }\n  }\n  \n  /**\n   * 执行任务\n   */\n  private async executeTask(task: RenderTask): Promise<void> {\n    const startTime = performance.now();\n    \n    try {\n      await task.execute();\n      \n      const executionTime = performance.now() - startTime;\n      this.metrics.renderTime += executionTime;\n      \n      if (task.onComplete) {\n        task.onComplete();\n      }\n    } catch (error) {\n      if (task.onError) {\n        task.onError(error as Error);\n      } else {\n        console.error('Task execution failed:', error);\n      }\n    }\n  }\n  \n  /**\n   * 缓存渲染结果\n   */\n  public cacheRender(key: string, data: any): void {\n    if (!this.config.enableRenderCache) return;\n    \n    // 检查缓存大小限制\n    const dataSize = this.estimateDataSize(data);\n    while (this.getCacheSize() + dataSize > this.config.cacheSize * 1024 * 1024) {\n      this.evictCacheEntry();\n    }\n    \n    this.renderCache.set(key, {\n      data,\n      timestamp: performance.now(),\n      accessCount: 1,\n      size: dataSize\n    });\n  }\n  \n  /**\n   * 获取缓存的渲染结果\n   */\n  public getCachedRender(key: string): any | null {\n    if (!this.config.enableRenderCache) return null;\n    \n    const cached = this.renderCache.get(key);\n    if (cached) {\n      cached.accessCount++;\n      cached.timestamp = performance.now();\n      this.cacheHits++;\n      return cached.data;\n    }\n    \n    this.cacheMisses++;\n    return null;\n  }\n  \n  /**\n   * 清理缓存\n   */\n  private cleanupCache(): void {\n    const currentTime = performance.now();\n    const maxAge = 60000; // 1分钟\n    \n    for (const [key, cached] of this.renderCache) {\n      if (currentTime - cached.timestamp > maxAge) {\n        this.renderCache.delete(key);\n      }\n    }\n  }\n  \n  /**\n   * 驱逐缓存条目\n   */\n  private evictCacheEntry(): void {\n    if (this.renderCache.size === 0) return;\n    \n    let keyToEvict = '';\n    let bestScore = Infinity;\n    \n    for (const [key, cached] of this.renderCache) {\n      let score: number;\n      \n      switch (this.config.cacheStrategy) {\n        case 'lru':\n          score = cached.timestamp;\n          break;\n        case 'lfu':\n          score = cached.accessCount;\n          break;\n        case 'adaptive':\n          // 综合考虑时间和访问次数\n          const age = performance.now() - cached.timestamp;\n          score = cached.accessCount / Math.log(age + 1);\n          break;\n        default:\n          score = cached.timestamp;\n      }\n      \n      if (score < bestScore) {\n        bestScore = score;\n        keyToEvict = key;\n      }\n    }\n    \n    if (keyToEvict) {\n      this.renderCache.delete(keyToEvict);\n    }\n  }\n  \n  /**\n   * 估算数据大小\n   */\n  private estimateDataSize(data: any): number {\n    // 简化的数据大小估算\n    if (data instanceof ImageData) {\n      return data.width * data.height * 4; // RGBA\n    } else if (data instanceof ArrayBuffer) {\n      return data.byteLength;\n    } else if (typeof data === 'string') {\n      return data.length * 2; // Unicode\n    } else {\n      return JSON.stringify(data).length * 2;\n    }\n  }\n  \n  /**\n   * 获取缓存大小\n   */\n  private getCacheSize(): number {\n    let totalSize = 0;\n    for (const cached of this.renderCache.values()) {\n      totalSize += cached.size || 0;\n    }\n    return totalSize;\n  }\n  \n  /**\n   * 启动垃圾回收\n   */\n  private startGarbageCollection(): void {\n    if (!this.config.enableGarbageCollection) return;\n    \n    setInterval(() => {\n      const currentTime = performance.now();\n      \n      if (currentTime - this.lastGCTime >= this.config.gcInterval) {\n        this.performGarbageCollection();\n        this.lastGCTime = currentTime;\n      }\n    }, this.config.gcInterval / 10);\n  }\n  \n  /**\n   * 执行垃圾回收\n   */\n  private performGarbageCollection(): void {\n    // 清理缓存\n    this.cleanupCache();\n    \n    // 清理任务队列中的过期任务\n    const currentTime = performance.now();\n    this.taskQueue = this.taskQueue.filter(task => task.deadline > currentTime);\n    \n    // 更新内存使用情况\n    this.updateMemoryUsage();\n    \n    this.gcCount++;\n    this.metrics.gcCount = this.gcCount;\n  }\n  \n  /**\n   * 更新内存使用情况\n   */\n  private updateMemoryUsage(): void {\n    if (typeof performance !== 'undefined' && (performance as any).memory) {\n      const memory = (performance as any).memory;\n      this.memoryUsage = memory.usedJSHeapSize / (1024 * 1024); // MB\n      this.metrics.memoryUsage = this.memoryUsage;\n    } else {\n      // 估算内存使用\n      this.memoryUsage = this.getCacheSize() / (1024 * 1024);\n      this.metrics.memoryUsage = this.memoryUsage;\n    }\n  }\n  \n  /**\n   * 更新性能指标\n   */\n  private updatePerformanceMetrics(entry: PerformanceEntry): void {\n    if (entry.name === 'frame-duration') {\n      this.metrics.frameTime = entry.duration;\n    }\n  }\n  \n  /**\n   * 获取性能指标\n   */\n  public getMetrics(): PerformanceMetrics {\n    // 更新缓存命中率\n    const totalRequests = this.cacheHits + this.cacheMisses;\n    this.metrics.cacheHitRate = totalRequests > 0 ? this.cacheHits / totalRequests : 0;\n    \n    return { ...this.metrics };\n  }\n  \n  /**\n   * 获取当前LOD级别\n   */\n  public getCurrentLOD(): number {\n    return this.currentLOD;\n  }\n  \n  /**\n   * 获取推荐的渲染策略\n   */\n  public getRecommendedStrategy(): string {\n    if (this.currentLOD < this.config.lodStrategies.length) {\n      return this.config.lodStrategies[this.currentLOD];\n    }\n    return 'skip';\n  }\n  \n  /**\n   * 检查是否应该跳过渲染\n   */\n  public shouldSkipRender(): boolean {\n    const avgFrameTime = this.frameTimeHistory.length > 0 ?\n      this.frameTimeHistory.reduce((sum, t) => sum + t, 0) / this.frameTimeHistory.length :\n      0;\n    \n    return avgFrameTime > this.config.maxFrameTime * 2;\n  }\n  \n  /**\n   * 优化建议\n   */\n  public getOptimizationSuggestions(): string[] {\n    const suggestions: string[] = [];\n    \n    if (this.metrics.averageFPS < this.config.targetFrameRate * 0.8) {\n      suggestions.push('Consider reducing data complexity or enabling LOD');\n    }\n    \n    if (this.metrics.memoryUsage > this.config.maxMemoryUsage * 0.8) {\n      suggestions.push('High memory usage detected, consider reducing cache size');\n    }\n    \n    if (this.metrics.cacheHitRate < 0.5) {\n      suggestions.push('Low cache hit rate, consider adjusting cache strategy');\n    }\n    \n    if (this.currentLOD > 2) {\n      suggestions.push('High LOD level active, performance may be impacted');\n    }\n    \n    return suggestions;\n  }\n  \n  /**\n   * 更新配置\n   */\n  public updateConfig(config: Partial<PerformanceConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n  \n  /**\n   * 重置指标\n   */\n  public resetMetrics(): void {\n    this.frameTimeHistory = [];\n    this.lodHistory = [];\n    this.frameCount = 0;\n    this.fpsUpdateTime = performance.now();\n    this.cacheHits = 0;\n    this.cacheMisses = 0;\n    this.gcCount = 0;\n    \n    this.metrics = {\n      currentFPS: 0,\n      averageFPS: 0,\n      frameTime: 0,\n      frameTimeHistory: [],\n      renderTime: 0,\n      updateTime: 0,\n      drawCalls: 0,\n      memoryUsage: 0,\n      cacheHitRate: 0,\n      gcCount: 0,\n      currentLOD: 0,\n      lodSwitches: 0,\n      qualityScore: 1.0\n    };\n  }\n  \n  /**\n   * 清理资源\n   */\n  public dispose(): void {\n    // 停止性能监控\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n      this.performanceObserver = null;\n    }\n    \n    // 清理缓存\n    this.renderCache.clear();\n    \n    // 清理任务队列\n    this.taskQueue = [];\n    this.runningTasks.clear();\n    \n    // 重置状态\n    this.isScheduling = false;\n  }\n}"