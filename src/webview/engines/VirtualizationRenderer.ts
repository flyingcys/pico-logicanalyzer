/**
 * 虚拟化渲染器
 * 用于优化大数据集的渲染性能
 */

import { AnalyzerChannel } from '../../models/CaptureModels';
import { ChannelDisplayInfo } from './ChannelLayoutManager';

export interface VirtualizationConfig {
  // LOD配置
  lodLevels: number[]; // LOD级别阈值
  maxSamplesPerPixel: number; // 每像素最大样本数
  minPixelsPerSample: number; // 每样本最小像素数
  
  // 虚拟化配置
  enableViewportCulling: boolean; // 启用视口剔除
  renderMargin: number; // 渲染边距（像素）
  chunkSize: number; // 数据块大小
  maxConcurrentChunks: number; // 最大并发块数
  
  // 缓存配置
  enableTileCache: boolean; // 启用瓦片缓存
  tileCacheSize: number; // 瓦片缓存大小 (MB)
  tileSize: number; // 瓦片大小（样本数）
  
  // 性能配置
  frameTimeTarget: number; // 目标帧时间 (ms)
  adaptiveLOD: boolean; // 自适应LOD
  enableWebWorker: boolean; // 启用Web Worker
}

export interface RenderTile {
  id: string;
  startSample: number;
  endSample: number;
  lodLevel: number;
  channelIndex: number;
  imageData: ImageData | null;
  lastUsed: number;
  renderTime: number;
}

export interface LODLevel {
  level: number;
  samplesPerPixel: number;
  renderStrategy: 'full' | 'minmax' | 'rle' | 'adaptive';
  compressionRatio: number;
}

export class VirtualizationRenderer {
  private config: VirtualizationConfig;
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  
  // 瓦片缓存
  private tileCache: Map<string, RenderTile> = new Map();
  private tileCacheSize = 0; // 当前缓存大小 (bytes)
  
  // LOD系统
  private lodLevels: LODLevel[] = [];
  private currentLOD = 0;
  
  // 性能监控
  private lastFrameTime = 0;
  private avgFrameTime = 16.67; // 60fps目标
  private frameTimeHistory: number[] = [];
  
  // Web Worker支持
  private renderWorker: Worker | null = null;
  private workerTasks: Map<string, Promise<any>> = new Map();
  
  // 渲染队列
  private renderQueue: RenderTask[] = [];
  private isRendering = false;
  
  constructor(canvas: HTMLCanvasElement, config?: Partial<VirtualizationConfig>) {
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      throw new Error('无法获取Canvas 2D上下文');
    }
    this.ctx = ctx;
    
    this.config = {
      lodLevels: [1, 2, 4, 8, 16, 32, 64, 128, 256],
      maxSamplesPerPixel: 1000,
      minPixelsPerSample: 0.1,
      enableViewportCulling: true,
      renderMargin: 100,
      chunkSize: 10000,
      maxConcurrentChunks: 4,
      enableTileCache: true,
      tileCacheSize: 100, // MB
      tileSize: 1000,
      frameTimeTarget: 16.67, // 60fps
      adaptiveLOD: true,
      enableWebWorker: true,
      ...config
    };
    
    this.initializeLODLevels();
    
    if (this.config.enableWebWorker && typeof Worker !== 'undefined') {\n      this.initializeWebWorker();\n    }\n  }\n  \n  /**\n   * 初始化LOD级别\n   */\n  private initializeLODLevels(): void {\n    this.lodLevels = this.config.lodLevels.map((samplesPerPixel, index) => ({\n      level: index,\n      samplesPerPixel,\n      renderStrategy: this.selectRenderStrategy(samplesPerPixel),\n      compressionRatio: Math.min(samplesPerPixel / 10, 1.0)\n    }));\n  }\n  \n  /**\n   * 选择渲染策略\n   */\n  private selectRenderStrategy(samplesPerPixel: number): 'full' | 'minmax' | 'rle' | 'adaptive' {\n    if (samplesPerPixel <= 1) {\n      return 'full';\n    } else if (samplesPerPixel <= 10) {\n      return 'minmax';\n    } else if (samplesPerPixel <= 100) {\n      return 'rle';\n    } else {\n      return 'adaptive';\n    }\n  }\n  \n  /**\n   * 初始化Web Worker\n   */\n  private initializeWebWorker(): void {\n    try {\n      // 创建内联Worker\n      const workerCode = `\n        self.onmessage = function(e) {\n          const { taskId, type, data } = e.data;\n          \n          try {\n            let result;\n            \n            switch (type) {\n              case 'minmax':\n                result = processMinMax(data);\n                break;\n              case 'rle':\n                result = processRLE(data);\n                break;\n              case 'downsample':\n                result = processDownsample(data);\n                break;\n              default:\n                throw new Error('Unknown task type: ' + type);\n            }\n            \n            self.postMessage({ taskId, success: true, result });\n          } catch (error) {\n            self.postMessage({ taskId, success: false, error: error.message });\n          }\n        };\n        \n        function processMinMax(data) {\n          const { samples, chunkSize } = data;\n          const result = [];\n          \n          for (let i = 0; i < samples.length; i += chunkSize) {\n            const chunk = samples.slice(i, i + chunkSize);\n            let min = 1, max = 0;\n            \n            for (const sample of chunk) {\n              if (sample < min) min = sample;\n              if (sample > max) max = sample;\n            }\n            \n            result.push({ min, max, start: i, end: i + chunk.length });\n          }\n          \n          return result;\n        }\n        \n        function processRLE(data) {\n          const { samples } = data;\n          const result = [];\n          let current = samples[0];\n          let count = 1;\n          \n          for (let i = 1; i < samples.length; i++) {\n            if (samples[i] === current) {\n              count++;\n            } else {\n              result.push({ value: current, count, start: i - count });\n              current = samples[i];\n              count = 1;\n            }\n          }\n          \n          result.push({ value: current, count, start: samples.length - count });\n          return result;\n        }\n        \n        function processDownsample(data) {\n          const { samples, factor } = data;\n          const result = [];\n          \n          for (let i = 0; i < samples.length; i += factor) {\n            // 简单下采样：取第一个样本\n            result.push(samples[i]);\n          }\n          \n          return result;\n        }\n      `;\n      \n      const blob = new Blob([workerCode], { type: 'application/javascript' });\n      this.renderWorker = new Worker(URL.createObjectURL(blob));\n      \n      this.renderWorker.onmessage = (e) => {\n        const { taskId, success, result, error } = e.data;\n        const task = this.workerTasks.get(taskId);\n        \n        if (task) {\n          this.workerTasks.delete(taskId);\n          if (success) {\n            task.resolve(result);\n          } else {\n            task.reject(new Error(error));\n          }\n        }\n      };\n      \n    } catch (error) {\n      console.warn('Failed to initialize Web Worker:', error);\n      this.renderWorker = null;\n    }\n  }\n  \n  /**\n   * 计算当前LOD级别\n   */\n  public calculateLOD(samplesPerPixel: number): number {\n    // 自适应LOD：基于帧时间调整\n    if (this.config.adaptiveLOD) {\n      const performanceFactor = this.avgFrameTime / this.config.frameTimeTarget;\n      samplesPerPixel *= performanceFactor;\n    }\n    \n    for (let i = 0; i < this.lodLevels.length; i++) {\n      if (samplesPerPixel <= this.lodLevels[i].samplesPerPixel) {\n        return i;\n      }\n    }\n    \n    return this.lodLevels.length - 1;\n  }\n  \n  /**\n   * 虚拟化渲染主方法\n   */\n  public async renderChannels(\n    channels: ChannelDisplayInfo[],\n    startSample: number,\n    endSample: number,\n    canvasWidth: number,\n    canvasHeight: number\n  ): Promise<void> {\n    const startTime = performance.now();\n    \n    // 计算渲染参数\n    const samplesPerPixel = (endSample - startSample) / canvasWidth;\n    const lodLevel = this.calculateLOD(samplesPerPixel);\n    \n    // 视口剔除：只渲染可见通道\n    const visibleChannels = this.config.enableViewportCulling ?\n      this.cullChannelsByViewport(channels, canvasHeight) :\n      channels;\n    \n    // 创建渲染任务\n    const renderTasks = this.createRenderTasks(\n      visibleChannels,\n      startSample,\n      endSample,\n      lodLevel,\n      canvasWidth\n    );\n    \n    // 执行渲染\n    await this.executeRenderTasks(renderTasks);\n    \n    // 更新性能统计\n    const renderTime = performance.now() - startTime;\n    this.updatePerformanceStats(renderTime);\n  }\n  \n  /**\n   * 视口剔除\n   */\n  private cullChannelsByViewport(\n    channels: ChannelDisplayInfo[],\n    canvasHeight: number\n  ): ChannelDisplayInfo[] {\n    const margin = this.config.renderMargin;\n    \n    return channels.filter(channel => {\n      const channelTop = channel.yPosition;\n      const channelBottom = channel.yPosition + channel.height;\n      \n      // 检查通道是否在可见区域内（包含边距）\n      return channelBottom >= -margin && channelTop <= canvasHeight + margin;\n    });\n  }\n  \n  /**\n   * 创建渲染任务\n   */\n  private createRenderTasks(\n    channels: ChannelDisplayInfo[],\n    startSample: number,\n    endSample: number,\n    lodLevel: number,\n    canvasWidth: number\n  ): RenderTask[] {\n    const tasks: RenderTask[] = [];\n    const samplesPerChunk = this.config.chunkSize;\n    \n    for (const channel of channels) {\n      // 将通道数据分块处理\n      for (let chunkStart = startSample; chunkStart < endSample; chunkStart += samplesPerChunk) {\n        const chunkEnd = Math.min(chunkStart + samplesPerChunk, endSample);\n        \n        tasks.push({\n          id: `${channel.originalIndex}_${chunkStart}_${chunkEnd}_${lodLevel}`,\n          channelInfo: channel,\n          startSample: chunkStart,\n          endSample: chunkEnd,\n          lodLevel,\n          priority: this.calculateTaskPriority(channel, chunkStart, chunkEnd)\n        });\n      }\n    }\n    \n    // 按优先级排序\n    tasks.sort((a, b) => b.priority - a.priority);\n    \n    return tasks;\n  }\n  \n  /**\n   * 计算任务优先级\n   */\n  private calculateTaskPriority(\n    channel: ChannelDisplayInfo,\n    startSample: number,\n    endSample: number\n  ): number {\n    let priority = 100;\n    \n    // 可见通道优先级更高\n    if (!channel.hidden) {\n      priority += 50;\n    }\n    \n    // 靠近视口中心的优先级更高\n    const distanceFromCenter = Math.abs((startSample + endSample) / 2 - (startSample + endSample) / 2);\n    priority -= distanceFromCenter * 0.001;\n    \n    return priority;\n  }\n  \n  /**\n   * 执行渲染任务\n   */\n  private async executeRenderTasks(tasks: RenderTask[]): Promise<void> {\n    const maxConcurrent = this.config.maxConcurrentChunks;\n    const executing: Promise<void>[] = [];\n    \n    for (const task of tasks) {\n      // 检查缓存\n      if (this.config.enableTileCache) {\n        const cachedTile = this.getTileFromCache(task.id);\n        if (cachedTile && cachedTile.imageData) {\n          this.renderCachedTile(cachedTile);\n          continue;\n        }\n      }\n      \n      // 限制并发数\n      if (executing.length >= maxConcurrent) {\n        await Promise.race(executing);\n      }\n      \n      const taskPromise = this.executeRenderTask(task).then(() => {\n        const index = executing.indexOf(taskPromise);\n        if (index !== -1) {\n          executing.splice(index, 1);\n        }\n      });\n      \n      executing.push(taskPromise);\n    }\n    \n    // 等待所有任务完成\n    await Promise.all(executing);\n  }\n  \n  /**\n   * 执行单个渲染任务\n   */\n  private async executeRenderTask(task: RenderTask): Promise<void> {\n    const lodLevel = this.lodLevels[task.lodLevel];\n    const channel = task.channelInfo.channel;\n    \n    if (!channel.samples) {\n      return;\n    }\n    \n    let processedData: any;\n    \n    // 根据LOD策略处理数据\n    switch (lodLevel.renderStrategy) {\n      case 'full':\n        processedData = this.processFullData(channel.samples, task.startSample, task.endSample);\n        break;\n      case 'minmax':\n        processedData = await this.processMinMaxData(channel.samples, task.startSample, task.endSample);\n        break;\n      case 'rle':\n        processedData = await this.processRLEData(channel.samples, task.startSample, task.endSample);\n        break;\n      case 'adaptive':\n        processedData = await this.processAdaptiveData(channel.samples, task.startSample, task.endSample, lodLevel);\n        break;\n    }\n    \n    // 渲染数据到瓦片\n    const tileData = this.renderDataToTile(processedData, task);\n    \n    // 缓存瓦片\n    if (this.config.enableTileCache) {\n      this.cacheTile(task.id, tileData);\n    }\n    \n    // 渲染到主画布\n    this.renderTileToCanvas(tileData, task);\n  }\n  \n  /**\n   * 处理完整数据（无压缩）\n   */\n  private processFullData(samples: Uint8Array, startSample: number, endSample: number): Uint8Array {\n    return samples.slice(startSample, endSample);\n  }\n  \n  /**\n   * 处理MinMax数据（压缩）\n   */\n  private async processMinMaxData(\n    samples: Uint8Array,\n    startSample: number,\n    endSample: number\n  ): Promise<any> {\n    const chunkSize = Math.max(1, Math.floor((endSample - startSample) / 1000));\n    \n    if (this.renderWorker) {\n      return this.executeWorkerTask('minmax', {\n        samples: samples.slice(startSample, endSample),\n        chunkSize\n      });\n    } else {\n      // 回退到主线程处理\n      return this.processMinMaxMainThread(samples, startSample, endSample, chunkSize);\n    }\n  }\n  \n  /**\n   * 主线程MinMax处理\n   */\n  private processMinMaxMainThread(\n    samples: Uint8Array,\n    startSample: number,\n    endSample: number,\n    chunkSize: number\n  ): any[] {\n    const result = [];\n    \n    for (let i = startSample; i < endSample; i += chunkSize) {\n      const chunkEnd = Math.min(i + chunkSize, endSample);\n      let min = 1, max = 0;\n      \n      for (let j = i; j < chunkEnd; j++) {\n        const sample = samples[j];\n        if (sample < min) min = sample;\n        if (sample > max) max = sample;\n      }\n      \n      result.push({ min, max, start: i, end: chunkEnd });\n    }\n    \n    return result;\n  }\n  \n  /**\n   * 处理RLE数据\n   */\n  private async processRLEData(\n    samples: Uint8Array,\n    startSample: number,\n    endSample: number\n  ): Promise<any> {\n    if (this.renderWorker) {\n      return this.executeWorkerTask('rle', {\n        samples: samples.slice(startSample, endSample)\n      });\n    } else {\n      // 回退到主线程处理\n      return this.processRLEMainThread(samples, startSample, endSample);\n    }\n  }\n  \n  /**\n   * 主线程RLE处理\n   */\n  private processRLEMainThread(\n    samples: Uint8Array,\n    startSample: number,\n    endSample: number\n  ): any[] {\n    const result = [];\n    let current = samples[startSample];\n    let count = 1;\n    \n    for (let i = startSample + 1; i < endSample; i++) {\n      if (samples[i] === current) {\n        count++;\n      } else {\n        result.push({ value: current, count, start: i - count });\n        current = samples[i];\n        count = 1;\n      }\n    }\n    \n    result.push({ value: current, count, start: endSample - count });\n    return result;\n  }\n  \n  /**\n   * 处理自适应数据\n   */\n  private async processAdaptiveData(\n    samples: Uint8Array,\n    startSample: number,\n    endSample: number,\n    lodLevel: LODLevel\n  ): Promise<any> {\n    // 根据性能情况动态选择策略\n    if (this.avgFrameTime > this.config.frameTimeTarget * 1.5) {\n      // 性能不足，使用更激进的压缩\n      return this.processRLEData(samples, startSample, endSample);\n    } else {\n      // 性能充足，使用较好的质量\n      return this.processMinMaxData(samples, startSample, endSample);\n    }\n  }\n  \n  /**\n   * 执行Worker任务\n   */\n  private executeWorkerTask(type: string, data: any): Promise<any> {\n    if (!this.renderWorker) {\n      throw new Error('Worker not available');\n    }\n    \n    const taskId = `${type}_${Date.now()}_${Math.random()}`;\n    \n    return new Promise((resolve, reject) => {\n      this.workerTasks.set(taskId, { resolve, reject } as any);\n      this.renderWorker!.postMessage({ taskId, type, data });\n      \n      // 设置超时\n      setTimeout(() => {\n        if (this.workerTasks.has(taskId)) {\n          this.workerTasks.delete(taskId);\n          reject(new Error('Worker task timeout'));\n        }\n      }, 5000);\n    });\n  }\n  \n  /**\n   * 将数据渲染到瓦片\n   */\n  private renderDataToTile(processedData: any, task: RenderTask): RenderTile {\n    // 创建离屏Canvas用于瓦片渲染\n    const tileCanvas = document.createElement('canvas');\n    const tileWidth = Math.min(this.canvas.width, 1024);\n    const tileHeight = task.channelInfo.height;\n    \n    tileCanvas.width = tileWidth;\n    tileCanvas.height = tileHeight;\n    \n    const tileCtx = tileCanvas.getContext('2d')!;\n    \n    // 渲染逻辑（简化版）\n    this.renderProcessedDataToContext(tileCtx, processedData, task, tileWidth, tileHeight);\n    \n    return {\n      id: task.id,\n      startSample: task.startSample,\n      endSample: task.endSample,\n      lodLevel: task.lodLevel,\n      channelIndex: task.channelInfo.originalIndex,\n      imageData: tileCtx.getImageData(0, 0, tileWidth, tileHeight),\n      lastUsed: Date.now(),\n      renderTime: 0\n    };\n  }\n  \n  /**\n   * 将处理后的数据渲染到Context\n   */\n  private renderProcessedDataToContext(\n    ctx: CanvasRenderingContext2D,\n    processedData: any,\n    task: RenderTask,\n    width: number,\n    height: number\n  ): void {\n    ctx.clearRect(0, 0, width, height);\n    \n    // 根据数据类型选择渲染方法\n    if (Array.isArray(processedData) && processedData[0]?.min !== undefined) {\n      // MinMax数据\n      this.renderMinMaxData(ctx, processedData, width, height);\n    } else if (Array.isArray(processedData) && processedData[0]?.value !== undefined) {\n      // RLE数据\n      this.renderRLEData(ctx, processedData, width, height);\n    } else {\n      // 原始数据\n      this.renderRawData(ctx, processedData, width, height);\n    }\n  }\n  \n  /**\n   * 渲染MinMax数据\n   */\n  private renderMinMaxData(\n    ctx: CanvasRenderingContext2D,\n    minMaxData: any[],\n    width: number,\n    height: number\n  ): void {\n    ctx.strokeStyle = '#00ff00';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    \n    const pixelsPerChunk = width / minMaxData.length;\n    \n    minMaxData.forEach((chunk, index) => {\n      const x = index * pixelsPerChunk;\n      \n      if (chunk.min === chunk.max) {\n        // 稳定信号\n        const y = chunk.min ? height * 0.2 : height * 0.8;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + pixelsPerChunk, y);\n      } else {\n        // 变化信号 - 绘制垂直线表示变化\n        ctx.moveTo(x, height * 0.2);\n        ctx.lineTo(x, height * 0.8);\n      }\n    });\n    \n    ctx.stroke();\n  }\n  \n  /**\n   * 渲染RLE数据\n   */\n  private renderRLEData(\n    ctx: CanvasRenderingContext2D,\n    rleData: any[],\n    width: number,\n    height: number\n  ): void {\n    ctx.strokeStyle = '#00ff00';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    \n    let currentX = 0;\n    const totalSamples = rleData.reduce((sum, segment) => sum + segment.count, 0);\n    \n    rleData.forEach(segment => {\n      const segmentWidth = (segment.count / totalSamples) * width;\n      const y = segment.value ? height * 0.2 : height * 0.8;\n      \n      ctx.moveTo(currentX, y);\n      ctx.lineTo(currentX + segmentWidth, y);\n      \n      currentX += segmentWidth;\n    });\n    \n    ctx.stroke();\n  }\n  \n  /**\n   * 渲染原始数据\n   */\n  private renderRawData(\n    ctx: CanvasRenderingContext2D,\n    rawData: Uint8Array,\n    width: number,\n    height: number\n  ): void {\n    ctx.strokeStyle = '#00ff00';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    \n    const pixelsPerSample = width / rawData.length;\n    \n    for (let i = 0; i < rawData.length; i++) {\n      const x = i * pixelsPerSample;\n      const y = rawData[i] ? height * 0.2 : height * 0.8;\n      \n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n    \n    ctx.stroke();\n  }\n  \n  /**\n   * 缓存瓦片\n   */\n  private cacheTile(tileId: string, tile: RenderTile): void {\n    // 检查缓存大小限制\n    if (tile.imageData) {\n      const tileSize = tile.imageData.width * tile.imageData.height * 4; // RGBA\n      \n      while (this.tileCacheSize + tileSize > this.config.tileCacheSize * 1024 * 1024) {\n        this.evictOldestTile();\n      }\n      \n      this.tileCache.set(tileId, tile);\n      this.tileCacheSize += tileSize;\n    }\n  }\n  \n  /**\n   * 从缓存获取瓦片\n   */\n  private getTileFromCache(tileId: string): RenderTile | null {\n    const tile = this.tileCache.get(tileId);\n    if (tile) {\n      tile.lastUsed = Date.now();\n      return tile;\n    }\n    return null;\n  }\n  \n  /**\n   * 淘汰最旧的瓦片\n   */\n  private evictOldestTile(): void {\n    let oldestTile: RenderTile | null = null;\n    let oldestTileId = '';\n    \n    for (const [tileId, tile] of this.tileCache) {\n      if (!oldestTile || tile.lastUsed < oldestTile.lastUsed) {\n        oldestTile = tile;\n        oldestTileId = tileId;\n      }\n    }\n    \n    if (oldestTile && oldestTile.imageData) {\n      const tileSize = oldestTile.imageData.width * oldestTile.imageData.height * 4;\n      this.tileCacheSize -= tileSize;\n      this.tileCache.delete(oldestTileId);\n    }\n  }\n  \n  /**\n   * 渲染缓存的瓦片\n   */\n  private renderCachedTile(tile: RenderTile): void {\n    if (tile.imageData) {\n      this.ctx.putImageData(tile.imageData, 0, 0); // 简化的位置计算\n    }\n  }\n  \n  /**\n   * 将瓦片渲染到主画布\n   */\n  private renderTileToCanvas(tile: RenderTile, task: RenderTask): void {\n    if (tile.imageData) {\n      const x = 0; // 简化的X位置计算\n      const y = task.channelInfo.yPosition;\n      \n      this.ctx.putImageData(tile.imageData, x, y);\n    }\n  }\n  \n  /**\n   * 更新性能统计\n   */\n  private updatePerformanceStats(renderTime: number): void {\n    this.frameTimeHistory.push(renderTime);\n    \n    // 保持历史记录在合理范围内\n    if (this.frameTimeHistory.length > 60) {\n      this.frameTimeHistory.shift();\n    }\n    \n    // 计算平均帧时间\n    this.avgFrameTime = this.frameTimeHistory.reduce((sum, time) => sum + time, 0) / this.frameTimeHistory.length;\n  }\n  \n  /**\n   * 获取性能统计\n   */\n  public getPerformanceStats(): any {\n    return {\n      avgFrameTime: this.avgFrameTime,\n      currentLOD: this.currentLOD,\n      cacheSize: this.tileCacheSize,\n      cacheHitRate: this.calculateCacheHitRate()\n    };\n  }\n  \n  /**\n   * 计算缓存命中率\n   */\n  private calculateCacheHitRate(): number {\n    // 简化实现，实际应该跟踪缓存命中和未命中次数\n    return this.tileCache.size > 0 ? 0.8 : 0;\n  }\n  \n  /**\n   * 清理资源\n   */\n  public dispose(): void {\n    // 清理Web Worker\n    if (this.renderWorker) {\n      this.renderWorker.terminate();\n      this.renderWorker = null;\n    }\n    \n    // 清理缓存\n    this.tileCache.clear();\n    this.tileCacheSize = 0;\n    \n    // 清理任务队列\n    this.renderQueue = [];\n    this.workerTasks.clear();\n  }\n}\n\n// 辅助接口\ninterface RenderTask {\n  id: string;\n  channelInfo: ChannelDisplayInfo;\n  startSample: number;\n  endSample: number;\n  lodLevel: number;\n  priority: number;\n}