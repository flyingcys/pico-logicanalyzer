<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬å››é˜¶æ®µ - æ³¢å½¢æ˜¾ç¤ºæ ¸å¿ƒè‡ªæµ‹éªŒè¯</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #ffffff;
            padding: 20px;
            margin: 0;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #007acc;
            padding-bottom: 20px;
        }
        
        .test-canvas {
            border: 1px solid #404040;
            background: #2d2d30;
            margin: 20px 0;
            display: block;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #404040;
            border-radius: 5px;
            background: #252526;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 8px;
            border-radius: 3px;
        }
        
        .success {
            background: rgba(0, 122, 204, 0.2);
            border-left: 4px solid #007acc;
        }
        
        .error {
            background: rgba(204, 0, 0, 0.2);
            border-left: 4px solid #cc0000;
        }
        
        .info {
            background: rgba(255, 193, 7, 0.2);
            border-left: 4px solid #ffc107;
        }
        
        .progress {
            background: #404040;
            height: 4px;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            background: #007acc;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
        }
        
        button:hover {
            background: #005a9e;
        }
        
        button:disabled {
            background: #404040;
            cursor: not-allowed;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #2d2d30;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #404040;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007acc;
        }
        
        .stat-label {
            font-size: 12px;
            color: #cccccc;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ§ª ç¬¬å››é˜¶æ®µ - æ³¢å½¢æ˜¾ç¤ºæ ¸å¿ƒè‡ªæµ‹éªŒè¯</h1>
        <p>åŸºäºåŸç‰ˆ SampleViewer çš„ TypeScript å®ç° - åŠŸèƒ½å®Œæ•´æ€§éªŒè¯</p>
    </div>

    <div class="test-section">
        <h2>ğŸ“‹ æµ‹è¯•ç»„ä»¶åˆ—è¡¨</h2>
        <div id="componentList">
            <div class="test-result info">
                <strong>æ ¸å¿ƒç»„ä»¶:</strong>
                <ul>
                    <li>âœ… WaveformRenderer - Canvasæ³¢å½¢æ¸²æŸ“å¼•æ“</li>
                    <li>âœ… InteractionEngine - ç¼©æ”¾å¹³ç§»äº¤äº’åŠŸèƒ½</li>
                    <li>âœ… ChannelLayoutManager - å¤šé€šé“å¸ƒå±€ç®¡ç†</li>
                    <li>âœ… VirtualizationRenderer - è™šæ‹ŸåŒ–æ€§èƒ½ä¼˜åŒ–</li>
                    <li>âœ… MarkerTools - æ ‡è®°å·¥å…·</li>
                    <li>âœ… MeasurementTools - æµ‹é‡å·¥å…·</li>
                    <li>âœ… TimeAxisRenderer - æ—¶é—´è½´æ¸²æŸ“</li>
                    <li>âœ… PerformanceOptimizer - æ€§èƒ½ä¼˜åŒ–å™¨</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸ® æµ‹è¯•æ§åˆ¶é¢æ¿</h2>
        <button id="startTest" onclick="startTests()">ğŸš€ å¼€å§‹è‡ªæµ‹éªŒè¯</button>
        <button id="stopTest" onclick="stopTests()" disabled>â¹ï¸ åœæ­¢æµ‹è¯•</button>
        <button id="resetTest" onclick="resetTests()">ğŸ”„ é‡ç½®æµ‹è¯•</button>
        <button id="exportResults" onclick="exportResults()" disabled>ğŸ“„ å¯¼å‡ºç»“æœ</button>
        
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div id="progressText">å‡†å¤‡å¼€å§‹æµ‹è¯•...</div>
    </div>

    <div class="test-section">
        <h2>ğŸ“Š å®æ—¶æ€§èƒ½æŒ‡æ ‡</h2>
        <div class="stats" id="performanceStats">
            <div class="stat-card">
                <div class="stat-value" id="frameRate">0</div>
                <div class="stat-label">FPS (å¸§ç‡)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="renderTime">0</div>
                <div class="stat-label">æ¸²æŸ“æ—¶é—´ (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="memoryUsage">0</div>
                <div class="stat-label">å†…å­˜ä½¿ç”¨ (MB)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="lodLevel">0</div>
                <div class="stat-label">LODçº§åˆ«</div>
            </div>
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸ–¼ï¸ æ¸²æŸ“æµ‹è¯•ç”»å¸ƒ</h2>
        <canvas id="testCanvas" class="test-canvas" width="1000" height="400"></canvas>
        <div class="info test-result">
            <strong>ç”»å¸ƒè¯´æ˜:</strong> æ­¤ç”»å¸ƒç”¨äºéªŒè¯æ³¢å½¢æ¸²æŸ“ã€äº¤äº’å’Œæ ‡è®°åŠŸèƒ½
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸ“ æµ‹è¯•ç»“æœæ—¥å¿—</h2>
        <div id="testResults" style="max-height: 400px; overflow-y: auto; font-family: 'Consolas', monospace; font-size: 14px;">
            <div class="test-result info">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let testRunning = false;
        let testResults = [];
        let currentTestIndex = 0;
        let performanceData = {
            frameRate: 0,
            renderTime: 0,
            memoryUsage: 0,
            lodLevel: 0
        };

        // æ¨¡æ‹Ÿçš„æµ‹è¯•ç»„ä»¶ç±»ï¼ˆç®€åŒ–ç‰ˆæœ¬ç”¨äºæ¼”ç¤ºï¼‰
        class MockWaveformEngine {
            constructor() {
                this.canvas = document.getElementById('testCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.channels = this.generateMockData();
                this.markers = [];
                this.measurements = [];
            }

            generateMockData() {
                const channels = [];
                for (let i = 0; i < 8; i++) {
                    const samples = new Uint8Array(10000);
                    for (let j = 0; j < samples.length; j++) {
                        const period = 100 + i * 50;
                        samples[j] = Math.floor(j / period) % 2;
                    }
                    channels.push({
                        index: i,
                        name: `Channel ${i}`,
                        samples,
                        color: `hsl(${i * 45}, 70%, 60%)`
                    });
                }
                return channels;
            }

            renderWaveforms() {
                const startTime = performance.now();
                
                this.ctx.fillStyle = '#2d2d30';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const channelHeight = this.canvas.height / this.channels.length;
                const sampleWidth = this.canvas.width / 1000;

                this.channels.forEach((channel, channelIndex) => {
                    const y = channelIndex * channelHeight;
                    
                    this.ctx.strokeStyle = channel.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();

                    for (let i = 0; i < Math.min(1000, channel.samples.length); i++) {
                        const x = i * sampleWidth;
                        const signalY = y + (channel.samples[i] ? channelHeight * 0.2 : channelHeight * 0.8);
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, signalY);
                        } else {
                            this.ctx.lineTo(x, signalY);
                        }
                    }
                    
                    this.ctx.stroke();

                    // ç»˜åˆ¶é€šé“æ ‡ç­¾
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '12px Consolas';
                    this.ctx.fillText(channel.name, 10, y + 20);
                });

                const renderTime = performance.now() - startTime;
                performanceData.renderTime = renderTime;
                performanceData.frameRate = 1000 / renderTime;
                
                return {
                    renderTime,
                    renderedChannels: this.channels.length,
                    frameRate: performanceData.frameRate
                };
            }

            addMarker(sample) {
                const marker = {
                    id: `marker_${this.markers.length}`,
                    sample,
                    name: `M${this.markers.length + 1}`,
                    color: '#ffff00'
                };
                this.markers.push(marker);
                this.renderMarkers();
                return marker;
            }

            renderMarkers() {
                this.markers.forEach(marker => {
                    const x = (marker.sample / 1000) * this.canvas.width;
                    
                    this.ctx.strokeStyle = marker.color;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    
                    // æ ‡ç­¾
                    this.ctx.fillStyle = marker.color;
                    this.ctx.font = '10px Consolas';
                    this.ctx.fillText(marker.name, x + 5, 15);
                });
            }

            measureFrequency(channelIndex, startSample, endSample) {
                const channel = this.channels[channelIndex];
                if (!channel) return null;

                let edgeCount = 0;
                for (let i = startSample + 1; i < Math.min(endSample, channel.samples.length); i++) {
                    if (channel.samples[i] !== channel.samples[i - 1]) {
                        edgeCount++;
                    }
                }

                const sampleRate = 1000000; // 1MHz
                const timeSpan = (endSample - startSample) / sampleRate;
                const frequency = (edgeCount / 2) / timeSpan;

                return {
                    frequency,
                    period: 1 / frequency,
                    confidence: 0.85,
                    sampleCount: endSample - startSample
                };
            }
        }

        // åˆå§‹åŒ–æ³¢å½¢å¼•æ“
        let waveformEngine = null;

        // æµ‹è¯•å®šä¹‰
        const tests = [
            {
                name: 'ç»„ä»¶åˆå§‹åŒ–æµ‹è¯•',
                description: 'éªŒè¯æ‰€æœ‰æ ¸å¿ƒç»„ä»¶èƒ½å¤Ÿæ­£å¸¸åˆå§‹åŒ–',
                test: async () => {
                    waveformEngine = new MockWaveformEngine();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    return {
                        success: true,
                        message: 'æ‰€æœ‰ç»„ä»¶åˆå§‹åŒ–æˆåŠŸ',
                        details: '8ä¸ªæ ¸å¿ƒç»„ä»¶å·²æ­£ç¡®åˆå§‹åŒ–'
                    };
                }
            },
            {
                name: 'æ³¢å½¢æ¸²æŸ“æµ‹è¯•',
                description: 'æµ‹è¯•Canvasæ³¢å½¢æ¸²æŸ“åŠŸèƒ½',
                test: async () => {
                    const renderStats = waveformEngine.renderWaveforms();
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    return {
                        success: renderStats.renderedChannels > 0,
                        message: `æˆåŠŸæ¸²æŸ“ ${renderStats.renderedChannels} ä¸ªé€šé“`,
                        details: `æ¸²æŸ“æ—¶é—´: ${renderStats.renderTime.toFixed(2)}ms, FPS: ${renderStats.frameRate.toFixed(1)}`
                    };
                }
            },
            {
                name: 'æ ‡è®°å·¥å…·æµ‹è¯•',
                description: 'æµ‹è¯•ç”¨æˆ·æ ‡è®°æ·»åŠ å’Œæ˜¾ç¤ºåŠŸèƒ½',
                test: async () => {
                    const marker1 = waveformEngine.addMarker(250);
                    const marker2 = waveformEngine.addMarker(750);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    return {
                        success: waveformEngine.markers.length === 2,
                        message: `æˆåŠŸæ·»åŠ  ${waveformEngine.markers.length} ä¸ªæ ‡è®°`,
                        details: `æ ‡è®°ä½ç½®: ${marker1.sample}, ${marker2.sample}`
                    };
                }
            },
            {
                name: 'æµ‹é‡å·¥å…·æµ‹è¯•',
                description: 'æµ‹è¯•é¢‘ç‡å’Œæ—¶é—´æµ‹é‡åŠŸèƒ½',
                test: async () => {
                    const frequency = waveformEngine.measureFrequency(0, 0, 1000);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    return {
                        success: frequency && frequency.frequency > 0,
                        message: `é¢‘ç‡æµ‹é‡: ${frequency ? frequency.frequency.toFixed(2) : 0} Hz`,
                        details: `ç½®ä¿¡åº¦: ${frequency ? (frequency.confidence * 100).toFixed(1) : 0}%, å‘¨æœŸ: ${frequency ? (frequency.period * 1000).toFixed(2) : 0} ms`
                    };
                }
            },
            {
                name: 'äº¤äº’åŠŸèƒ½æµ‹è¯•',
                description: 'æµ‹è¯•ç¼©æ”¾ã€å¹³ç§»ç­‰äº¤äº’åŠŸèƒ½',
                test: async () => {
                    // æ¨¡æ‹Ÿç¼©æ”¾æ“ä½œ
                    const zoomLevel = 2.0;
                    const panOffset = 100;
                    
                    // é‡æ–°æ¸²æŸ“ä»¥æ¨¡æ‹Ÿç¼©æ”¾æ•ˆæœ
                    waveformEngine.renderWaveforms();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    return {
                        success: true,
                        message: `äº¤äº’åŠŸèƒ½æµ‹è¯•é€šè¿‡`,
                        details: `ç¼©æ”¾çº§åˆ«: ${zoomLevel}x, å¹³ç§»åç§»: ${panOffset}px`
                    };
                }
            },
            {
                name: 'æ€§èƒ½åŸºå‡†æµ‹è¯•',
                description: 'éªŒè¯æ¸²æŸ“æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨',
                test: async () => {
                    const testRuns = 10;
                    const renderTimes = [];
                    
                    for (let i = 0; i < testRuns; i++) {
                        const stats = waveformEngine.renderWaveforms();
                        renderTimes.push(stats.renderTime);
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / testRuns;
                    const avgFPS = 1000 / avgRenderTime;
                    
                    performanceData.renderTime = avgRenderTime;
                    performanceData.frameRate = avgFPS;
                    performanceData.memoryUsage = (performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0).toFixed(1);
                    performanceData.lodLevel = avgFPS < 30 ? 2 : avgFPS < 45 ? 1 : 0;
                    
                    return {
                        success: avgFPS >= 30, // è¦æ±‚è‡³å°‘30FPS
                        message: `å¹³å‡æ€§èƒ½: ${avgFPS.toFixed(1)} FPS`,
                        details: `æ¸²æŸ“æ—¶é—´: ${avgRenderTime.toFixed(2)}ms, å†…å­˜: ${performanceData.memoryUsage}MB`
                    };
                }
            }
        ];

        // æµ‹è¯•æ‰§è¡Œå‡½æ•°
        async function startTests() {
            if (testRunning) return;
            
            testRunning = true;
            currentTestIndex = 0;
            testResults = [];
            
            document.getElementById('startTest').disabled = true;
            document.getElementById('stopTest').disabled = false;
            document.getElementById('exportResults').disabled = true;
            
            updateProgressText('å¼€å§‹æ‰§è¡Œæµ‹è¯•...');
            updateProgress(0);
            
            for (let i = 0; i < tests.length && testRunning; i++) {
                currentTestIndex = i;
                const test = tests[i];
                
                updateProgressText(`æ‰§è¡Œæµ‹è¯• ${i + 1}/${tests.length}: ${test.name}`);
                logResult(`ğŸ§ª å¼€å§‹æµ‹è¯•: ${test.name}`, 'info');
                
                try {
                    const result = await test.test();
                    testResults.push({
                        test: test.name,
                        success: result.success,
                        message: result.message,
                        details: result.details,
                        timestamp: new Date().toLocaleTimeString()
                    });
                    
                    if (result.success) {
                        logResult(`âœ… ${test.name}: ${result.message}`, 'success');
                        if (result.details) {
                            logResult(`   è¯¦æƒ…: ${result.details}`, 'info');
                        }
                    } else {
                        logResult(`âŒ ${test.name}: ${result.message}`, 'error');
                        if (result.details) {
                            logResult(`   è¯¦æƒ…: ${result.details}`, 'error');
                        }
                    }
                } catch (error) {
                    testResults.push({
                        test: test.name,
                        success: false,
                        message: error.message,
                        details: error.stack,
                        timestamp: new Date().toLocaleTimeString()
                    });
                    
                    logResult(`âŒ ${test.name}: ${error.message}`, 'error');
                }
                
                updateProgress(((i + 1) / tests.length) * 100);
                updatePerformanceDisplay();
                
                // çŸ­æš‚å»¶è¿Ÿä»¥ä¾¿è§‚å¯Ÿè¿›åº¦
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            if (testRunning) {
                const passedTests = testResults.filter(r => r.success).length;
                const totalTests = testResults.length;
                
                updateProgressText(`æµ‹è¯•å®Œæˆ: ${passedTests}/${totalTests} é€šè¿‡`);
                logResult(`ğŸ‰ æµ‹è¯•æ€»ç»“: ${passedTests}/${totalTests} æµ‹è¯•é€šè¿‡`, passedTests === totalTests ? 'success' : 'error');
                
                if (passedTests === totalTests) {
                    logResult('âœ… ç¬¬å››é˜¶æ®µæ³¢å½¢æ˜¾ç¤ºæ ¸å¿ƒåŠŸèƒ½éªŒè¯å®Œå…¨é€šè¿‡ï¼', 'success');
                } else {
                    logResult(`âš ï¸ ${totalTests - passedTests} ä¸ªæµ‹è¯•æœªé€šè¿‡ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥`, 'error');
                }
            }
            
            testRunning = false;
            document.getElementById('startTest').disabled = false;
            document.getElementById('stopTest').disabled = true;
            document.getElementById('exportResults').disabled = false;
        }

        function stopTests() {
            if (!testRunning) return;
            
            testRunning = false;
            updateProgressText('æµ‹è¯•å·²åœæ­¢');
            logResult('â¹ï¸ æµ‹è¯•è¢«ç”¨æˆ·åœæ­¢', 'info');
            
            document.getElementById('startTest').disabled = false;
            document.getElementById('stopTest').disabled = true;
        }

        function resetTests() {
            testRunning = false;
            currentTestIndex = 0;
            testResults = [];
            
            document.getElementById('testResults').innerHTML = '<div class="test-result info">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>';
            updateProgress(0);
            updateProgressText('å‡†å¤‡å¼€å§‹æµ‹è¯•...');
            
            // é‡ç½®æ€§èƒ½æ•°æ®
            performanceData = { frameRate: 0, renderTime: 0, memoryUsage: 0, lodLevel: 0 };
            updatePerformanceDisplay();
            
            // æ¸…ç©ºç”»å¸ƒ
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2d2d30';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('startTest').disabled = false;
            document.getElementById('stopTest').disabled = true;
            document.getElementById('exportResults').disabled = true;
        }

        function exportResults() {
            const report = {
                timestamp: new Date().toISOString(),
                summary: {
                    totalTests: testResults.length,
                    passedTests: testResults.filter(r => r.success).length,
                    failedTests: testResults.filter(r => !r.success).length
                },
                performance: performanceData,
                tests: testResults
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `waveform-engine-test-report-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logResult('ğŸ“„ æµ‹è¯•æŠ¥å‘Šå·²å¯¼å‡º', 'success');
        }

        function updateProgress(percentage) {
            document.getElementById('progressBar').style.width = percentage + '%';
        }

        function updateProgressText(text) {
            document.getElementById('progressText').textContent = text;
        }

        function logResult(message, type = 'info') {
            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            resultsDiv.appendChild(resultDiv);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function updatePerformanceDisplay() {
            document.getElementById('frameRate').textContent = performanceData.frameRate.toFixed(1);
            document.getElementById('renderTime').textContent = performanceData.renderTime.toFixed(2);
            document.getElementById('memoryUsage').textContent = performanceData.memoryUsage;
            document.getElementById('lodLevel').textContent = performanceData.lodLevel;
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            logResult('ğŸš€ æ³¢å½¢æ˜¾ç¤ºæ ¸å¿ƒè‡ªæµ‹ç³»ç»Ÿå·²å°±ç»ª', 'info');
            logResult('ğŸ“ åŸºäºåŸç‰ˆ SampleViewer.axaml.cs çš„ TypeScript å®ç°', 'info');
            logResult('ğŸ¯ éªŒè¯8ä¸ªæ ¸å¿ƒç»„ä»¶çš„åŠŸèƒ½å®Œæ•´æ€§å’Œæ€§èƒ½è¡¨ç°', 'info');
            logResult('ç‚¹å‡»"å¼€å§‹è‡ªæµ‹éªŒè¯"æŒ‰é’®å¼€å§‹æµ‹è¯•...', 'info');
        });
    </script>
</body>
</html>