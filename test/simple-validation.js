/**
 * ç®€å•çš„ Week 2 åŠŸèƒ½éªŒè¯
 * ä¸ä¾èµ–å¤æ‚çš„å¯¼å…¥ï¼ŒåªéªŒè¯æ ¸å¿ƒé€»è¾‘
 */

console.log('ğŸš€ Week 2 åŠŸèƒ½éªŒè¯å¼€å§‹...\n');

/**
 * æµ‹è¯• 1: éªŒè¯æ ¸å¿ƒæ•°æ®ç»“æ„
 */
function testDataStructures() {
    console.log('ğŸ“Š æµ‹è¯• 1: æ ¸å¿ƒæ•°æ®ç»“æ„éªŒè¯');
    
    try {
        // æ¨¡æ‹Ÿç»Ÿä¸€æ•°æ®æ ¼å¼ç»“æ„
        const mockUnifiedData = {
            version: '1.0.0',
            formatType: 'unified-v1',
            metadata: {
                deviceInfo: {
                    name: 'Test Device',
                    type: 'Serial',
                    isNetwork: false
                },
                captureId: 'test-123',
                timestamp: Date.now(),
                duration: 100,
                sampleRate: 10000000,
                totalSamples: 10000,
                timebase: {
                    sampleRate: 10000000,
                    sampleInterval: 100,
                    timeOffset: 0,
                    precision: 1
                },
                captureMode: 'normal'
            },
            channels: [
                {
                    channelNumber: 0,
                    channelName: 'Channel 1',
                    channelColor: '#00ff00',
                    enabled: true,
                    hidden: false
                },
                {
                    channelNumber: 1,
                    channelName: 'Channel 2', 
                    channelColor: '#ff0000',
                    enabled: true,
                    hidden: false
                }
            ],
            samples: {
                digital: {
                    data: [new Uint8Array(1000), new Uint8Array(1000)],
                    encoding: 'binary'
                }
            },
            quality: {
                lostSamples: 0,
                errorRate: 0,
                calibrationStatus: true,
                overruns: 0,
                underruns: 0,
                signalIntegrity: 100
            }
        };
        
        // éªŒè¯æ•°æ®ç»“æ„å®Œæ•´æ€§
        const hasRequiredFields = \n            mockUnifiedData.version &&\n            mockUnifiedData.formatType &&\n            mockUnifiedData.metadata &&\n            mockUnifiedData.channels &&\n            mockUnifiedData.samples &&\n            mockUnifiedData.quality;\n        \n        console.log(`  âœ… æ•°æ®ç»“æ„åˆ›å»º: æˆåŠŸ`);\n        console.log(`  âœ… å¿…éœ€å­—æ®µæ£€æŸ¥: ${hasRequiredFields ? 'å®Œæ•´' : 'ç¼ºå¤±'}`);\n        console.log(`  âœ… é€šé“æ•°é‡: ${mockUnifiedData.channels.length}`);\n        console.log(`  âœ… æ ·æœ¬æ•°é‡: ${mockUnifiedData.metadata.totalSamples}`);\n        console.log(`  âœ… é‡‡æ ·ç‡: ${(mockUnifiedData.metadata.sampleRate / 1000000).toFixed(1)}MHz`);\n        \n        return hasRequiredFields;\n    } catch (error) {\n        console.log(`  âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);\n        return false;\n    }\n}\n\n/**\n * æµ‹è¯• 2: æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆé€»è¾‘\n */\nfunction testDataGeneration() {\n    console.log('\\nğŸ² æµ‹è¯• 2: æ•°æ®ç”Ÿæˆé€»è¾‘éªŒè¯');\n    \n    try {\n        // æ¨¡æ‹Ÿæ—¶é’Ÿä¿¡å·ç”Ÿæˆ\n        function generateClockSignal(sampleCount, frequency, sampleRate) {\n            const samples = new Uint8Array(sampleCount);\n            const samplesPerCycle = sampleRate / frequency;\n            const halfCycle = samplesPerCycle / 2;\n            \n            for (let i = 0; i < sampleCount; i++) {\n                const cyclePosition = i % samplesPerCycle;\n                samples[i] = cyclePosition < halfCycle ? 1 : 0;\n            }\n            \n            return samples;\n        }\n        \n        // æ¨¡æ‹Ÿéšæœºä¿¡å·ç”Ÿæˆ\n        function generateRandomSignal(sampleCount) {\n            const samples = new Uint8Array(sampleCount);\n            for (let i = 0; i < sampleCount; i++) {\n                samples[i] = Math.random() > 0.5 ? 1 : 0;\n            }\n            return samples;\n        }\n        \n        // æ¨¡æ‹Ÿè®¡æ•°å™¨ä¿¡å·ç”Ÿæˆ\n        function generateCounterSignal(sampleCount, bitPosition) {\n            const samples = new Uint8Array(sampleCount);\n            let counter = 0;\n            \n            for (let i = 0; i < sampleCount; i++) {\n                if (i % 100 === 0) { // æ¯100ä¸ªæ ·æœ¬è®¡æ•°ä¸€æ¬¡\n                    counter++;\n                }\n                samples[i] = (counter >> bitPosition) & 1;\n            }\n            \n            return samples;\n        }\n        \n        // æµ‹è¯•å„ç§ä¿¡å·ç”Ÿæˆ\n        const clockSamples = generateClockSignal(1000, 1000000, 10000000); // 1MHzæ—¶é’Ÿ\n        const randomSamples = generateRandomSignal(1000);\n        const counterSamples = generateCounterSignal(1000, 0);\n        \n        // éªŒè¯ç”Ÿæˆçš„æ•°æ®\n        const clockPeriodic = checkPeriodicity(clockSamples, 10); // æ£€æŸ¥å‘¨æœŸæ€§\n        const randomEntropy = calculateEntropy(randomSamples); // æ£€æŸ¥éšæœºæ€§\n        const counterProgression = checkProgression(counterSamples); // æ£€æŸ¥é€’å¢\n        \n        console.log(`  âœ… æ—¶é’Ÿä¿¡å·ç”Ÿæˆ: æˆåŠŸ (å‘¨æœŸæ€§: ${clockPeriodic ? 'æ˜¯' : 'å¦'})`);\n        console.log(`  âœ… éšæœºä¿¡å·ç”Ÿæˆ: æˆåŠŸ (ç†µå€¼: ${randomEntropy.toFixed(2)})`);\n        console.log(`  âœ… è®¡æ•°å™¨ç”Ÿæˆ: æˆåŠŸ (é€’å¢: ${counterProgression ? 'æ˜¯' : 'å¦'})`);\n        console.log(`  âœ… æ ·æœ¬æ•°æ®ç±»å‹: ${clockSamples.constructor.name}`);\n        \n        return clockSamples.length === 1000 && randomSamples.length === 1000;\n    } catch (error) {\n        console.log(`  âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);\n        return false;\n    }\n}\n\n/**\n * æµ‹è¯• 3: é…ç½®é€‚é…é€»è¾‘\n */\nfunction testConfigurationAdaptation() {\n    console.log('\\nğŸ”§ æµ‹è¯• 3: é…ç½®é€‚é…é€»è¾‘éªŒè¯');\n    \n    try {\n        // æ¨¡æ‹Ÿç¡¬ä»¶èƒ½åŠ›\n        const hardwareCapabilities = {\n            maxChannels: 16,\n            maxFrequency: 50000000, // 50MHz\n            bufferSize: 32768,\n            supportedFrequencies: [1000, 10000, 100000, 1000000, 10000000, 50000000]\n        };\n        \n        // æ¨¡æ‹Ÿç”¨æˆ·é…ç½®\n        const userConfig = {\n            frequency: 100000000, // 100MHz - è¶…å‡ºç¡¬ä»¶èƒ½åŠ›\n            channels: Array.from({length: 24}, (_, i) => i), // 24é€šé“ - è¶…å‡ºç¡¬ä»¶èƒ½åŠ›\n            sampleCount: 100000\n        };\n        \n        // é€‚é…é€»è¾‘\n        function adaptConfiguration(config, capabilities) {\n            const adapted = { ...config };\n            const warnings = [];\n            const errors = [];\n            \n            // é¢‘ç‡é€‚é…\n            if (config.frequency > capabilities.maxFrequency) {\n                const closestFreq = capabilities.supportedFrequencies\n                    .reduce((closest, current) => \n                        Math.abs(current - config.frequency) < Math.abs(closest - config.frequency) \n                        ? current : closest\n                    );\n                adapted.frequency = Math.min(closestFreq, capabilities.maxFrequency);\n                warnings.push(`é¢‘ç‡ä» ${config.frequency}Hz è°ƒæ•´ä¸º ${adapted.frequency}Hz`);\n            }\n            \n            // é€šé“é€‚é…\n            if (config.channels.length > capabilities.maxChannels) {\n                adapted.channels = config.channels.slice(0, capabilities.maxChannels);\n                warnings.push(`é€šé“æ•°ä» ${config.channels.length} å‡å°‘åˆ° ${adapted.channels.length}`);\n            }\n            \n            // ç¼“å†²åŒºæ£€æŸ¥\n            if (config.sampleCount > capabilities.bufferSize) {\n                adapted.sampleCount = capabilities.bufferSize;\n                warnings.push(`æ ·æœ¬æ•°ä» ${config.sampleCount} è°ƒæ•´ä¸º ${adapted.sampleCount}`);\n            }\n            \n            return {\n                success: errors.length === 0,\n                adaptedConfig: adapted,\n                warnings,\n                errors\n            };\n        }\n        \n        const result = adaptConfiguration(userConfig, hardwareCapabilities);\n        \n        console.log(`  âœ… é€‚é…æ‰§è¡Œ: æˆåŠŸ`);\n        console.log(`  âœ… é€‚é…ç»“æœ: ${result.success ? 'æˆåŠŸ' : 'å¤±è´¥'}`);\n        console.log(`  âœ… é¢‘ç‡è°ƒæ•´: ${userConfig.frequency}Hz -> ${result.adaptedConfig.frequency}Hz`);\n        console.log(`  âœ… é€šé“è°ƒæ•´: ${userConfig.channels.length} -> ${result.adaptedConfig.channels.length}`);\n        console.log(`  âœ… è­¦å‘Šæ•°é‡: ${result.warnings.length}`);\n        console.log(`  âœ… é”™è¯¯æ•°é‡: ${result.errors.length}`);\n        \n        return result.success && result.warnings.length > 0;\n    } catch (error) {\n        console.log(`  âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);\n        return false;\n    }\n}\n\n/**\n * æµ‹è¯• 4: æ¸²æŸ“æ€§èƒ½æ¨¡æ‹Ÿ\n */\nfunction testRenderingPerformance() {\n    console.log('\\nâš¡ æµ‹è¯• 4: æ¸²æŸ“æ€§èƒ½æ¨¡æ‹Ÿ');\n    \n    try {\n        // æ¨¡æ‹Ÿæ¸²æŸ“æ•°æ®å¤„ç†\n        function simulateRenderingProcess(sampleCount, channelCount) {\n            const startTime = performance.now();\n            \n            // æ¨¡æ‹Ÿåƒç´ è®¡ç®—å’Œæ¸²æŸ“æ“ä½œ\n            let operations = 0;\n            const canvasWidth = 1200;\n            const samplesPerPixel = sampleCount / canvasWidth;\n            \n            // æ¨¡æ‹Ÿæ¯ä¸ªåƒç´ çš„è®¡ç®—\n            for (let pixel = 0; pixel < canvasWidth; pixel++) {\n                for (let channel = 0; channel < channelCount; channel++) {\n                    // æ¨¡æ‹Ÿæ ·æœ¬åˆ°åƒç´ çš„è½¬æ¢è®¡ç®—\n                    const sampleStart = Math.floor(pixel * samplesPerPixel);\n                    const sampleEnd = Math.floor((pixel + 1) * samplesPerPixel);\n                    \n                    // æ¨¡æ‹Ÿä¿¡å·ç”µå¹³è®¡ç®—\n                    let value = 0;\n                    for (let s = sampleStart; s < sampleEnd && s < sampleCount; s++) {\n                        value += Math.sin(s * 0.01) > 0 ? 1 : 0; // æ¨¡æ‹Ÿä¿¡å·å€¼\n                        operations++;\n                    }\n                    \n                    // æ¨¡æ‹Ÿç»˜åˆ¶æ“ä½œ\n                    operations += 3; // moveTo, lineTo, stroke\n                }\n            }\n            \n            const endTime = performance.now();\n            const renderTime = endTime - startTime;\n            \n            return {\n                renderTime,\n                operations,\n                fps: 1000 / renderTime,\n                samplesPerSecond: operations / (renderTime / 1000)\n            };\n        }\n        \n        // æµ‹è¯•ä¸åŒè§„æ¨¡çš„æ•°æ®\n        const test1 = simulateRenderingProcess(10000, 8);   // 1ä¸‡æ ·æœ¬ï¼Œ8é€šé“\n        const test2 = simulateRenderingProcess(100000, 8);  // 10ä¸‡æ ·æœ¬ï¼Œ8é€šé“\n        const test3 = simulateRenderingProcess(100000, 16); // 10ä¸‡æ ·æœ¬ï¼Œ16é€šé“\n        \n        console.log(`  âœ… å°æ•°æ®é›†æ¸²æŸ“: ${test1.renderTime.toFixed(2)}ms (${test1.fps.toFixed(1)}fps)`);\n        console.log(`  âœ… ä¸­æ•°æ®é›†æ¸²æŸ“: ${test2.renderTime.toFixed(2)}ms (${test2.fps.toFixed(1)}fps)`);\n        console.log(`  âœ… å¤§æ•°æ®é›†æ¸²æŸ“: ${test3.renderTime.toFixed(2)}ms (${test3.fps.toFixed(1)}fps)`);\n        console.log(`  âœ… å¤„ç†æ“ä½œæ•°: ${test2.operations.toLocaleString()}`);\n        console.log(`  âœ… æ€§èƒ½åŸºå‡†: ${test2.renderTime < 100 ? 'âœ… é€šè¿‡' : 'âŒ éœ€ä¼˜åŒ–'}`);\n        \n        return test1.renderTime < 50 && test2.renderTime < 100;\n    } catch (error) {\n        console.log(`  âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);\n        return false;\n    }\n}\n\n/**\n * æµ‹è¯• 5: äº¤äº’åŠŸèƒ½é€»è¾‘\n */\nfunction testInteractionLogic() {\n    console.log('\\nğŸ–±ï¸  æµ‹è¯• 5: äº¤äº’åŠŸèƒ½é€»è¾‘éªŒè¯');\n    \n    try {\n        // æ¨¡æ‹Ÿè§†å›¾èŒƒå›´çŠ¶æ€\n        const viewRange = {\n            startSample: 0,\n            endSample: 10000,\n            samplesPerPixel: 8.33, // 10000 / 1200\n            zoomLevel: 1\n        };\n        \n        // æ¨¡æ‹Ÿç¼©æ”¾æ“ä½œ\n        function simulateZoom(viewRange, zoomFactor, centerSample) {\n            const currentRange = viewRange.endSample - viewRange.startSample;\n            const newRange = currentRange / zoomFactor;\n            \n            // è®¡ç®—æ–°çš„è§†å›¾èŒƒå›´\n            const centerRatio = (centerSample - viewRange.startSample) / currentRange;\n            const newStart = centerSample - newRange * centerRatio;\n            const newEnd = newStart + newRange;\n            \n            return {\n                startSample: Math.max(0, newStart),\n                endSample: newEnd,\n                samplesPerPixel: newRange / 1200,\n                zoomLevel: viewRange.zoomLevel * zoomFactor\n            };\n        }\n        \n        // æ¨¡æ‹Ÿå¹³ç§»æ“ä½œ\n        function simulatePan(viewRange, pixelDelta) {\n            const sampleDelta = pixelDelta * viewRange.samplesPerPixel;\n            \n            return {\n                ...viewRange,\n                startSample: Math.max(0, viewRange.startSample - sampleDelta),\n                endSample: viewRange.endSample - sampleDelta\n            };\n        }\n        \n        // æµ‹è¯•äº¤äº’æ“ä½œ\n        const originalRange = { ...viewRange };\n        const zoomedRange = simulateZoom(viewRange, 2.0, 5000); // 2å€ç¼©æ”¾ï¼Œä¸­å¿ƒåœ¨5000æ ·æœ¬\n        const pannedRange = simulatePan(zoomedRange, 100); // å‘å³å¹³ç§»100åƒç´ \n        \n        console.log(`  âœ… åŸå§‹èŒƒå›´: ${originalRange.startSample} - ${originalRange.endSample} (${originalRange.samplesPerPixel.toFixed(2)} samples/px)`);\n        console.log(`  âœ… ç¼©æ”¾å: ${zoomedRange.startSample.toFixed(0)} - ${zoomedRange.endSample.toFixed(0)} (${zoomedRange.samplesPerPixel.toFixed(2)} samples/px)`);\n        console.log(`  âœ… å¹³ç§»å: ${pannedRange.startSample.toFixed(0)} - ${pannedRange.endSample.toFixed(0)}`);\n        console.log(`  âœ… ç¼©æ”¾çº§åˆ«: ${originalRange.zoomLevel}x -> ${zoomedRange.zoomLevel}x`);\n        console.log(`  âœ… äº¤äº’å“åº”: æ­£å¸¸`);\n        \n        return zoomedRange.zoomLevel === 2.0 && zoomedRange.samplesPerPixel < originalRange.samplesPerPixel;\n    } catch (error) {\n        console.log(`  âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);\n        return false;\n    }\n}\n\n/**\n * è¾…åŠ©å‡½æ•°\n */\nfunction checkPeriodicity(samples, expectedPeriod) {\n    // ç®€å•çš„å‘¨æœŸæ€§æ£€æŸ¥\n    let matches = 0;\n    const checkLength = Math.min(samples.length, expectedPeriod * 10);\n    \n    for (let i = expectedPeriod; i < checkLength; i++) {\n        if (samples[i] === samples[i - expectedPeriod]) {\n            matches++;\n        }\n    }\n    \n    return matches > (checkLength - expectedPeriod) * 0.8; // 80%åŒ¹é…ç‡è®¤ä¸ºæ˜¯å‘¨æœŸæ€§çš„\n}\n\nfunction calculateEntropy(samples) {\n    // è®¡ç®—é¦™å†œç†µ\n    const counts = { 0: 0, 1: 0 };\n    for (const sample of samples) {\n        counts[sample]++;\n    }\n    \n    const total = samples.length;\n    let entropy = 0;\n    \n    for (const count of Object.values(counts)) {\n        if (count > 0) {\n            const p = count / total;\n            entropy -= p * Math.log2(p);\n        }\n    }\n    \n    return entropy;\n}\n\nfunction checkProgression(samples) {\n    // æ£€æŸ¥æ˜¯å¦æœ‰é€’å¢è¶‹åŠ¿\n    let increases = 0;\n    for (let i = 1; i < Math.min(samples.length, 100); i++) {\n        if (samples[i] !== samples[i-1]) {\n            increases++;\n        }\n    }\n    return increases > 5; // æœ‰å˜åŒ–å°±è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„\n}\n\n/**\n * è¿è¡Œæ‰€æœ‰æµ‹è¯•\n */\nfunction runAllTests() {\n    const results = [];\n    \n    results.push({ name: 'æ ¸å¿ƒæ•°æ®ç»“æ„éªŒè¯', passed: testDataStructures() });\n    results.push({ name: 'æ•°æ®ç”Ÿæˆé€»è¾‘éªŒè¯', passed: testDataGeneration() });\n    results.push({ name: 'é…ç½®é€‚é…é€»è¾‘éªŒè¯', passed: testConfigurationAdaptation() });\n    results.push({ name: 'æ¸²æŸ“æ€§èƒ½æ¨¡æ‹Ÿ', passed: testRenderingPerformance() });\n    results.push({ name: 'äº¤äº’åŠŸèƒ½é€»è¾‘éªŒè¯', passed: testInteractionLogic() });\n    \n    // è¾“å‡ºæµ‹è¯•æ±‡æ€»\n    console.log('\\nğŸ“‹ Week 2 åŠŸèƒ½éªŒè¯æ±‡æ€»');\n    console.log('=' .repeat(40));\n    \n    const passed = results.filter(r => r.passed).length;\n    const total = results.length;\n    \n    results.forEach(result => {\n        const status = result.passed ? 'âœ… PASS' : 'âŒ FAIL';\n        console.log(`${status} ${result.name}`);\n    });\n    \n    console.log('-'.repeat(40));\n    console.log(`æ€»è®¡: ${total} ä¸ªæµ‹è¯•`);\n    console.log(`é€šè¿‡: ${passed} ä¸ªæµ‹è¯•`);\n    console.log(`å¤±è´¥: ${total - passed} ä¸ªæµ‹è¯•`);\n    console.log(`é€šè¿‡ç‡: ${(passed / total * 100).toFixed(1)}%`);\n    \n    if (passed === total) {\n        console.log('\\nğŸ‰ æ‰€æœ‰åŠŸèƒ½éªŒè¯é€šè¿‡ï¼Week 2 æ ¸å¿ƒé€»è¾‘å®ç°æ­£ç¡®ã€‚');\n        console.log('âœ¨ å·²éªŒè¯åŠŸèƒ½:');\n        console.log('  â€¢ ç»Ÿä¸€æ•°æ®æ ¼å¼ç»“æ„è®¾è®¡ âœ…');\n        console.log('  â€¢ å¤šç§ä¿¡å·æ¨¡å¼ç”Ÿæˆé€»è¾‘ âœ…'); \n        console.log('  â€¢ ç¡¬ä»¶é…ç½®æ™ºèƒ½é€‚é…é€»è¾‘ âœ…');\n        console.log('  â€¢ é«˜æ€§èƒ½æ¸²æŸ“å¤„ç†æ¨¡æ‹Ÿ âœ…');\n        console.log('  â€¢ ç¼©æ”¾å¹³ç§»äº¤äº’é€»è¾‘ âœ…');\n        console.log('\\nğŸš€ Week 2 å¼€å‘ç›®æ ‡è¾¾æˆï¼Œç³»ç»Ÿæ¶æ„éªŒè¯é€šè¿‡ï¼');\n    } else {\n        console.log('\\nâš ï¸  éƒ¨åˆ†åŠŸèƒ½éªŒè¯æœªé€šè¿‡ï¼Œè¯·æ£€æŸ¥ç›¸å…³é€»è¾‘å®ç°ã€‚');\n    }\n    \n    return passed === total;\n}\n\n// è¿è¡ŒéªŒè¯\nrunAllTests();"