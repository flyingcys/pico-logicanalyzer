/**\n * Week 2 性能测试\n * 测试大数据量渲染性能，验证是否满足性能基准要求\n * 基准要求:\n * - 100万样本数据渲染时间 < 16ms (60fps)\n * - 内存使用增长 < 100MB  \n * - 缩放平移响应延迟 < 50ms\n */\n\nimport { MockDataGenerator, SignalPattern, GeneratorConfig } from '../src/drivers/MockDataGenerator';\nimport { WaveformRenderer, RenderStats } from '../src/webview/engines/WaveformRenderer';\nimport { InteractionEngine, InteractionMode } from '../src/webview/engines/InteractionEngine';\nimport { CapabilityAdapter, AdaptationStrategy } from '../src/drivers/CapabilityAdapter';\nimport { UnifiedDataFormat, ViewRange } from '../src/models/UnifiedDataFormat';\nimport { AnalyzerDriverType, CaptureConfiguration, TriggerType } from '../src/models/AnalyzerTypes';\n\n// 性能测试配置\ninterface PerformanceTestConfig {\n    testName: string;\n    sampleCount: number;\n    channelCount: number;\n    sampleRate: number;\n    iterations: number;\n    expectedRenderTime: number; // ms\n    expectedMemoryLimit: number; // MB\n}\n\n// 测试结果\ninterface TestResult {\n    testName: string;\n    passed: boolean;\n    metrics: {\n        avgRenderTime: number;\n        maxRenderTime: number;\n        minRenderTime: number;\n        avgMemoryUsage: number;\n        maxMemoryUsage: number;\n        fps: number;\n        samplesPerSecond: number;\n    };\n    errors: string[];\n    warnings: string[];\n}\n\n// 内存监控工具\nclass MemoryMonitor {\n    private baseline: number = 0;\n    private measurements: number[] = [];\n    \n    start(): void {\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            this.baseline = process.memoryUsage().heapUsed / 1024 / 1024; // MB\n        } else {\n            this.baseline = 0;\n        }\n        this.measurements = [];\n    }\n    \n    measure(): number {\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            const current = process.memoryUsage().heapUsed / 1024 / 1024; // MB\n            const usage = current - this.baseline;\n            this.measurements.push(usage);\n            return usage;\n        }\n        return 0;\n    }\n    \n    getStats() {\n        if (this.measurements.length === 0) {\n            return { avg: 0, max: 0, min: 0 };\n        }\n        \n        return {\n            avg: this.measurements.reduce((a, b) => a + b, 0) / this.measurements.length,\n            max: Math.max(...this.measurements),\n            min: Math.min(...this.measurements)\n        };\n    }\n}\n\nexport class Week2PerformanceTest {\n    private canvas: HTMLCanvasElement;\n    private renderer: WaveformRenderer | null = null;\n    private interactionEngine: InteractionEngine | null = null;\n    private memoryMonitor = new MemoryMonitor();\n    \n    constructor() {\n        // 创建虚拟Canvas用于测试\n        this.canvas = this.createVirtualCanvas(1200, 600);\n    }\n    \n    /**\n     * 运行所有性能测试\n     */\n    async runAllTests(): Promise<TestResult[]> {\n        console.log('🚀 开始 Week 2 性能测试...');\n        \n        const testConfigs: PerformanceTestConfig[] = [\n            {\n                testName: '基准性能测试 - 10万样本',\n                sampleCount: 100000,\n                channelCount: 8,\n                sampleRate: 10000000,\n                iterations: 10,\n                expectedRenderTime: 16, // 60fps要求\n                expectedMemoryLimit: 50 // MB\n            },\n            {\n                testName: '大数据量测试 - 100万样本',\n                sampleCount: 1000000,\n                channelCount: 8,\n                sampleRate: 100000000,\n                iterations: 5,\n                expectedRenderTime: 16, // 主要性能基准\n                expectedMemoryLimit: 100 // MB\n            },\n            {\n                testName: '多通道性能测试 - 24通道',\n                sampleCount: 500000,\n                channelCount: 24,\n                sampleRate: 50000000,\n                iterations: 5,\n                expectedRenderTime: 20,\n                expectedMemoryLimit: 80\n            },\n            {\n                testName: '高频采样测试',\n                sampleCount: 200000,\n                channelCount: 8,\n                sampleRate: 100000000, // 100MHz\n                iterations: 10,\n                expectedRenderTime: 16,\n                expectedMemoryLimit: 60\n            },\n            {\n                testName: '极限压力测试 - 500万样本',\n                sampleCount: 5000000,\n                channelCount: 16,\n                sampleRate: 100000000,\n                iterations: 3,\n                expectedRenderTime: 50, // 放宽要求\n                expectedMemoryLimit: 200\n            }\n        ];\n        \n        const results: TestResult[] = [];\n        \n        for (const config of testConfigs) {\n            console.log(`\\n📊 运行测试: ${config.testName}`);\n            const result = await this.runSingleTest(config);\n            results.push(result);\n            \n            // 输出测试结果\n            this.printTestResult(result);\n            \n            // 强制垃圾回收\n            if (typeof global !== 'undefined' && global.gc) {\n                global.gc();\n            }\n            \n            // 测试间隔\n            await this.sleep(1000);\n        }\n        \n        // 输出汇总报告\n        this.printSummaryReport(results);\n        \n        return results;\n    }\n    \n    /**\n     * 运行单个性能测试\n     */\n    private async runSingleTest(config: PerformanceTestConfig): Promise<TestResult> {\n        const result: TestResult = {\n            testName: config.testName,\n            passed: false,\n            metrics: {\n                avgRenderTime: 0,\n                maxRenderTime: 0,\n                minRenderTime: Infinity,\n                avgMemoryUsage: 0,\n                maxMemoryUsage: 0,\n                fps: 0,\n                samplesPerSecond: 0\n            },\n            errors: [],\n            warnings: []\n        };\n        \n        try {\n            // 生成测试数据\n            console.log(`  📈 生成 ${config.sampleCount} 样本数据...`);\n            const testData = await this.generateTestData(config);\n            \n            // 验证数据格式\n            if (!UnifiedDataFormat.validate(testData)) {\n                result.errors.push('数据格式验证失败');\n                return result;\n            }\n            \n            // 初始化渲染器\n            this.initializeRenderer();\n            if (!this.renderer) {\n                result.errors.push('渲染器初始化失败');\n                return result;\n            }\n            \n            // 内存监控开始\n            this.memoryMonitor.start();\n            \n            // 运行渲染性能测试\n            const renderTimes: number[] = [];\n            \n            for (let i = 0; i < config.iterations; i++) {\n                const startTime = performance.now();\n                \n                // 执行渲染\n                const renderStats = this.renderer.renderWaveform(testData, {\n                    startSample: 0,\n                    endSample: Math.min(config.sampleCount, 10000),\n                    samplesPerPixel: config.sampleCount / 1200,\n                    timePerPixel: 1000,\n                    zoomLevel: 1\n                });\n                \n                const endTime = performance.now();\n                const renderTime = endTime - startTime;\n                renderTimes.push(renderTime);\n                \n                // 监控内存使用\n                this.memoryMonitor.measure();\n                \n                // 避免浏览器阻塞\n                if (i % 2 === 0) {\n                    await this.sleep(10);\n                }\n            }\n            \n            // 计算统计指标\n            result.metrics.avgRenderTime = renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length;\n            result.metrics.maxRenderTime = Math.max(...renderTimes);\n            result.metrics.minRenderTime = Math.min(...renderTimes);\n            \n            const memoryStats = this.memoryMonitor.getStats();\n            result.metrics.avgMemoryUsage = memoryStats.avg;\n            result.metrics.maxMemoryUsage = memoryStats.max;\n            \n            result.metrics.fps = 1000 / result.metrics.avgRenderTime;\n            result.metrics.samplesPerSecond = config.sampleCount / (result.metrics.avgRenderTime / 1000);\n            \n            // 测试交互性能\n            await this.testInteractionPerformance(testData, result);\n            \n            // 验证性能基准\n            result.passed = this.validatePerformance(result.metrics, config, result);\n            \n        } catch (error) {\n            result.errors.push(`测试执行错误: ${error}`);\n        } finally {\n            this.cleanup();\n        }\n        \n        return result;\n    }\n    \n    /**\n     * 测试交互性能\n     */\n    private async testInteractionPerformance(testData: any, result: TestResult): Promise<void> {\n        if (!this.interactionEngine) {\n            this.interactionEngine = new InteractionEngine(this.canvas, {\n                startSample: 0,\n                endSample: 10000,\n                samplesPerPixel: 1,\n                timePerPixel: 1000,\n                zoomLevel: 1\n            });\n        }\n        \n        // 测试缩放性能\n        const zoomTimes: number[] = [];\n        for (let i = 0; i < 5; i++) {\n            const startTime = performance.now();\n            this.interactionEngine.zoomIn(1.5);\n            const endTime = performance.now();\n            zoomTimes.push(endTime - startTime);\n        }\n        \n        const avgZoomTime = zoomTimes.reduce((a, b) => a + b, 0) / zoomTimes.length;\n        \n        if (avgZoomTime > 50) {\n            result.warnings.push(`缩放响应时间 ${avgZoomTime.toFixed(2)}ms 超过预期 (50ms)`);\n        }\n    }\n    \n    /**\n     * 验证性能是否符合基准\n     */\n    private validatePerformance(\n        metrics: TestResult['metrics'], \n        config: PerformanceTestConfig, \n        result: TestResult\n    ): boolean {\n        let passed = true;\n        \n        // 渲染时间检查\n        if (metrics.avgRenderTime > config.expectedRenderTime) {\n            result.errors.push(\n                `平均渲染时间 ${metrics.avgRenderTime.toFixed(2)}ms 超过预期 ${config.expectedRenderTime}ms`\n            );\n            passed = false;\n        }\n        \n        // 内存使用检查\n        if (metrics.maxMemoryUsage > config.expectedMemoryLimit) {\n            result.errors.push(\n                `最大内存使用 ${metrics.maxMemoryUsage.toFixed(2)}MB 超过限制 ${config.expectedMemoryLimit}MB`\n            );\n            passed = false;\n        }\n        \n        // 帧率检查\n        if (metrics.fps < 30) {\n            result.warnings.push(\n                `帧率 ${metrics.fps.toFixed(1)}fps 低于建议值 30fps`\n            );\n        }\n        \n        // 吞吐量检查\n        const expectedThroughput = config.sampleCount * 10; // 每秒至少处理10倍样本\n        if (metrics.samplesPerSecond < expectedThroughput) {\n            result.warnings.push(\n                `样本处理吞吐量 ${metrics.samplesPerSecond.toFixed(0)} samples/s 低于预期`\n            );\n        }\n        \n        return passed;\n    }\n    \n    /**\n     * 生成测试数据\n     */\n    private async generateTestData(config: PerformanceTestConfig) {\n        const generatorConfig: GeneratorConfig = {\n            deviceType: AnalyzerDriverType.Serial,\n            channelCount: config.channelCount,\n            sampleRate: config.sampleRate,\n            sampleCount: config.sampleCount,\n            patterns: this.generateTestPatterns(config.channelCount),\n            noiseLevel: 0.01, // 1%噪声\n            jitter: 1\n        };\n        \n        return MockDataGenerator.generateCaptureData(generatorConfig);\n    }\n    \n    /**\n     * 生成测试模式\n     */\n    private generateTestPatterns(channelCount: number) {\n        const patterns = [];\n        \n        for (let i = 0; i < channelCount; i++) {\n            if (i % 4 === 0) {\n                patterns.push({ channel: i, pattern: SignalPattern.Clock, frequency: 1000000 * (i + 1) });\n            } else if (i % 4 === 1) {\n                patterns.push({ channel: i, pattern: SignalPattern.Counter });\n            } else if (i % 4 === 2) {\n                patterns.push({ channel: i, pattern: SignalPattern.Random });\n            } else {\n                patterns.push({ channel: i, pattern: SignalPattern.PWM, frequency: 10000, dutyCycle: 0.5 });\n            }\n        }\n        \n        return patterns;\n    }\n    \n    /**\n     * 初始化渲染器\n     */\n    private initializeRenderer(): void {\n        try {\n            this.renderer = new WaveformRenderer(this.canvas);\n        } catch (error) {\n            console.error('渲染器初始化失败:', error);\n        }\n    }\n    \n    /**\n     * 创建虚拟Canvas\n     */\n    private createVirtualCanvas(width: number, height: number): HTMLCanvasElement {\n        // 在Node.js环境中，这里需要使用canvas库\n        // 在浏览器环境中，直接创建Canvas元素\n        if (typeof document !== 'undefined') {\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            return canvas;\n        } else {\n            // Node.js环境的模拟实现\n            return {\n                width,\n                height,\n                getContext: () => ({\n                    clearRect: () => {},\n                    fillRect: () => {},\n                    strokeRect: () => {},\n                    beginPath: () => {},\n                    moveTo: () => {},\n                    lineTo: () => {},\n                    stroke: () => {},\n                    fill: () => {},\n                    fillText: () => {},\n                    measureText: () => ({ width: 50 }),\n                    scale: () => {},\n                    save: () => {},\n                    restore: () => {},\n                    drawImage: () => {}\n                }),\n                addEventListener: () => {},\n                removeEventListener: () => {},\n                getBoundingClientRect: () => ({ left: 0, top: 0, width, height }),\n                style: {}\n            } as any;\n        }\n    }\n    \n    /**\n     * 输出测试结果\n     */\n    private printTestResult(result: TestResult): void {\n        const status = result.passed ? '✅ PASS' : '❌ FAIL';\n        console.log(`  ${status} ${result.testName}`);\n        console.log(`    平均渲染时间: ${result.metrics.avgRenderTime.toFixed(2)}ms`);\n        console.log(`    最大渲染时间: ${result.metrics.maxRenderTime.toFixed(2)}ms`);\n        console.log(`    平均内存使用: ${result.metrics.avgMemoryUsage.toFixed(2)}MB`);\n        console.log(`    最大内存使用: ${result.metrics.maxMemoryUsage.toFixed(2)}MB`);\n        console.log(`    帧率: ${result.metrics.fps.toFixed(1)}fps`);\n        console.log(`    样本吞吐: ${(result.metrics.samplesPerSecond / 1000000).toFixed(1)}M samples/s`);\n        \n        if (result.errors.length > 0) {\n            console.log(`    错误:`);\n            result.errors.forEach(error => console.log(`      - ${error}`));\n        }\n        \n        if (result.warnings.length > 0) {\n            console.log(`    警告:`);\n            result.warnings.forEach(warning => console.log(`      - ${warning}`));\n        }\n    }\n    \n    /**\n     * 输出汇总报告\n     */\n    private printSummaryReport(results: TestResult[]): void {\n        console.log('\\n📋 Week 2 性能测试汇总报告');\n        console.log('=' .repeat(50));\n        \n        const passed = results.filter(r => r.passed).length;\n        const total = results.length;\n        \n        console.log(`总测试数: ${total}`);\n        console.log(`通过测试: ${passed}`);\n        console.log(`失败测试: ${total - passed}`);\n        console.log(`通过率: ${(passed / total * 100).toFixed(1)}%`);\n        \n        // 性能统计\n        const allMetrics = results.map(r => r.metrics);\n        const avgRenderTime = allMetrics.reduce((sum, m) => sum + m.avgRenderTime, 0) / allMetrics.length;\n        const maxMemoryUsage = Math.max(...allMetrics.map(m => m.maxMemoryUsage));\n        const avgFps = allMetrics.reduce((sum, m) => sum + m.fps, 0) / allMetrics.length;\n        \n        console.log('\\n🎯 性能基准评估:');\n        console.log(`  平均渲染时间: ${avgRenderTime.toFixed(2)}ms (目标: <16ms)`);\n        console.log(`  最大内存使用: ${maxMemoryUsage.toFixed(2)}MB (目标: <100MB)`);\n        console.log(`  平均帧率: ${avgFps.toFixed(1)}fps (目标: >30fps)`);\n        \n        // 基准达成情况\n        const renderTimeBenchmark = avgRenderTime < 16;\n        const memoryBenchmark = maxMemoryUsage < 100;\n        const fpsBenchmark = avgFps > 30;\n        \n        console.log('\\n📊 基准达成情况:');\n        console.log(`  渲染性能: ${renderTimeBenchmark ? '✅ 达成' : '❌ 未达成'}`);\n        console.log(`  内存使用: ${memoryBenchmark ? '✅ 达成' : '❌ 未达成'}`);\n        console.log(`  帧率表现: ${fpsBenchmark ? '✅ 达成' : '❌ 未达成'}`);\n        \n        const overallSuccess = renderTimeBenchmark && memoryBenchmark && fpsBenchmark;\n        console.log(`\\n🏆 Week 2 性能目标: ${overallSuccess ? '✅ 全部达成' : '❌ 部分未达成'}`);\n        \n        if (!overallSuccess) {\n            console.log('\\n🔧 优化建议:');\n            if (!renderTimeBenchmark) {\n                console.log('  - 优化渲染算法，考虑使用WebGL加速');\n                console.log('  - 实现更激进的LOD策略');\n                console.log('  - 使用Web Workers进行数据预处理');\n            }\n            if (!memoryBenchmark) {\n                console.log('  - 实现数据分页加载');\n                console.log('  - 优化缓存策略，及时释放不用的数据');\n                console.log('  - 使用更高效的数据结构');\n            }\n            if (!fpsBenchmark) {\n                console.log('  - 使用requestAnimationFrame优化动画');\n                console.log('  - 减少重绘频率');\n                console.log('  - 优化交互响应机制');\n            }\n        }\n    }\n    \n    /**\n     * 运行CapabilityAdapter性能测试\n     */\n    async testCapabilityAdapter(): Promise<void> {\n        console.log('\\n🔧 测试CapabilityAdapter性能...');\n        \n        const adapter = new CapabilityAdapter({\n            strategy: AdaptationStrategy.Adaptive\n        });\n        \n        // 创建测试配置\n        const testConfigs: CaptureConfiguration[] = [\n            {\n                frequency: 100000000,\n                preTriggerSamples: 50000,\n                postTriggerSamples: 950000,\n                triggerType: TriggerType.Edge,\n                triggerChannel: 0,\n                triggerInverted: false,\n                loopCount: 0,\n                measureBursts: false,\n                captureChannels: Array.from({length: 24}, (_, i) => i)\n            }\n        ];\n        \n        const deviceInfo = {\n            name: 'Test Device',\n            type: AnalyzerDriverType.Serial,\n            isNetwork: false,\n            capabilities: {} as any\n        };\n        \n        const startTime = performance.now();\n        \n        // 运行适配测试\n        for (let i = 0; i < 100; i++) {\n            const result = adapter.adaptConfiguration(testConfigs[0], deviceInfo);\n            if (!result.success) {\n                console.log(`  适配失败: ${result.errors.join(', ')}`);\n            }\n        }\n        \n        const endTime = performance.now();\n        const avgTime = (endTime - startTime) / 100;\n        \n        console.log(`  平均适配时间: ${avgTime.toFixed(3)}ms`);\n        console.log(`  适配性能: ${avgTime < 1 ? '✅ 优秀' : avgTime < 5 ? '⚠️ 良好' : '❌ 需优化'}`);\n    }\n    \n    /**\n     * 工具方法\n     */\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    private cleanup(): void {\n        if (this.renderer) {\n            this.renderer.dispose();\n            this.renderer = null;\n        }\n        \n        if (this.interactionEngine) {\n            this.interactionEngine.dispose();\n            this.interactionEngine = null;\n        }\n    }\n}\n\n// 主测试入口\nexport async function runWeek2PerformanceTests(): Promise<void> {\n    const tester = new Week2PerformanceTest();\n    \n    try {\n        const results = await tester.runAllTests();\n        \n        // 运行CapabilityAdapter测试\n        await tester.testCapabilityAdapter();\n        \n        // 检查是否所有核心测试都通过\n        const criticalTests = results.filter(r => \n            r.testName.includes('100万样本') || \n            r.testName.includes('基准性能')\n        );\n        \n        const allCriticalPassed = criticalTests.every(r => r.passed);\n        \n        if (allCriticalPassed) {\n            console.log('\\n🎉 Week 2 性能测试全部通过！系统已准备好进入Week 3开发。');\n        } else {\n            console.log('\\n⚠️ 部分关键性能测试未通过，建议优化后再进入下一阶段。');\n        }\n        \n    } catch (error) {\n        console.error('性能测试执行失败:', error);\n    }\n}\n\n// 如果直接运行此文件\nif (require.main === module) {\n    runWeek2PerformanceTests();\n}"