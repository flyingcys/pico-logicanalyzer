/**\n * Week 2 æ€§èƒ½æµ‹è¯•\n * æµ‹è¯•å¤§æ•°æ®é‡æ¸²æŸ“æ€§èƒ½ï¼ŒéªŒè¯æ˜¯å¦æ»¡è¶³æ€§èƒ½åŸºå‡†è¦æ±‚\n * åŸºå‡†è¦æ±‚:\n * - 100ä¸‡æ ·æœ¬æ•°æ®æ¸²æŸ“æ—¶é—´ < 16ms (60fps)\n * - å†…å­˜ä½¿ç”¨å¢é•¿ < 100MB  \n * - ç¼©æ”¾å¹³ç§»å“åº”å»¶è¿Ÿ < 50ms\n */\n\nimport { MockDataGenerator, SignalPattern, GeneratorConfig } from '../src/drivers/MockDataGenerator';\nimport { WaveformRenderer, RenderStats } from '../src/webview/engines/WaveformRenderer';\nimport { InteractionEngine, InteractionMode } from '../src/webview/engines/InteractionEngine';\nimport { CapabilityAdapter, AdaptationStrategy } from '../src/drivers/CapabilityAdapter';\nimport { UnifiedDataFormat, ViewRange } from '../src/models/UnifiedDataFormat';\nimport { AnalyzerDriverType, CaptureConfiguration, TriggerType } from '../src/models/AnalyzerTypes';\n\n// æ€§èƒ½æµ‹è¯•é…ç½®\ninterface PerformanceTestConfig {\n    testName: string;\n    sampleCount: number;\n    channelCount: number;\n    sampleRate: number;\n    iterations: number;\n    expectedRenderTime: number; // ms\n    expectedMemoryLimit: number; // MB\n}\n\n// æµ‹è¯•ç»“æœ\ninterface TestResult {\n    testName: string;\n    passed: boolean;\n    metrics: {\n        avgRenderTime: number;\n        maxRenderTime: number;\n        minRenderTime: number;\n        avgMemoryUsage: number;\n        maxMemoryUsage: number;\n        fps: number;\n        samplesPerSecond: number;\n    };\n    errors: string[];\n    warnings: string[];\n}\n\n// å†…å­˜ç›‘æ§å·¥å…·\nclass MemoryMonitor {\n    private baseline: number = 0;\n    private measurements: number[] = [];\n    \n    start(): void {\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            this.baseline = process.memoryUsage().heapUsed / 1024 / 1024; // MB\n        } else {\n            this.baseline = 0;\n        }\n        this.measurements = [];\n    }\n    \n    measure(): number {\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            const current = process.memoryUsage().heapUsed / 1024 / 1024; // MB\n            const usage = current - this.baseline;\n            this.measurements.push(usage);\n            return usage;\n        }\n        return 0;\n    }\n    \n    getStats() {\n        if (this.measurements.length === 0) {\n            return { avg: 0, max: 0, min: 0 };\n        }\n        \n        return {\n            avg: this.measurements.reduce((a, b) => a + b, 0) / this.measurements.length,\n            max: Math.max(...this.measurements),\n            min: Math.min(...this.measurements)\n        };\n    }\n}\n\nexport class Week2PerformanceTest {\n    private canvas: HTMLCanvasElement;\n    private renderer: WaveformRenderer | null = null;\n    private interactionEngine: InteractionEngine | null = null;\n    private memoryMonitor = new MemoryMonitor();\n    \n    constructor() {\n        // åˆ›å»ºè™šæ‹ŸCanvasç”¨äºæµ‹è¯•\n        this.canvas = this.createVirtualCanvas(1200, 600);\n    }\n    \n    /**\n     * è¿è¡Œæ‰€æœ‰æ€§èƒ½æµ‹è¯•\n     */\n    async runAllTests(): Promise<TestResult[]> {\n        console.log('ğŸš€ å¼€å§‹ Week 2 æ€§èƒ½æµ‹è¯•...');\n        \n        const testConfigs: PerformanceTestConfig[] = [\n            {\n                testName: 'åŸºå‡†æ€§èƒ½æµ‹è¯• - 10ä¸‡æ ·æœ¬',\n                sampleCount: 100000,\n                channelCount: 8,\n                sampleRate: 10000000,\n                iterations: 10,\n                expectedRenderTime: 16, // 60fpsè¦æ±‚\n                expectedMemoryLimit: 50 // MB\n            },\n            {\n                testName: 'å¤§æ•°æ®é‡æµ‹è¯• - 100ä¸‡æ ·æœ¬',\n                sampleCount: 1000000,\n                channelCount: 8,\n                sampleRate: 100000000,\n                iterations: 5,\n                expectedRenderTime: 16, // ä¸»è¦æ€§èƒ½åŸºå‡†\n                expectedMemoryLimit: 100 // MB\n            },\n            {\n                testName: 'å¤šé€šé“æ€§èƒ½æµ‹è¯• - 24é€šé“',\n                sampleCount: 500000,\n                channelCount: 24,\n                sampleRate: 50000000,\n                iterations: 5,\n                expectedRenderTime: 20,\n                expectedMemoryLimit: 80\n            },\n            {\n                testName: 'é«˜é¢‘é‡‡æ ·æµ‹è¯•',\n                sampleCount: 200000,\n                channelCount: 8,\n                sampleRate: 100000000, // 100MHz\n                iterations: 10,\n                expectedRenderTime: 16,\n                expectedMemoryLimit: 60\n            },\n            {\n                testName: 'æé™å‹åŠ›æµ‹è¯• - 500ä¸‡æ ·æœ¬',\n                sampleCount: 5000000,\n                channelCount: 16,\n                sampleRate: 100000000,\n                iterations: 3,\n                expectedRenderTime: 50, // æ”¾å®½è¦æ±‚\n                expectedMemoryLimit: 200\n            }\n        ];\n        \n        const results: TestResult[] = [];\n        \n        for (const config of testConfigs) {\n            console.log(`\\nğŸ“Š è¿è¡Œæµ‹è¯•: ${config.testName}`);\n            const result = await this.runSingleTest(config);\n            results.push(result);\n            \n            // è¾“å‡ºæµ‹è¯•ç»“æœ\n            this.printTestResult(result);\n            \n            // å¼ºåˆ¶åƒåœ¾å›æ”¶\n            if (typeof global !== 'undefined' && global.gc) {\n                global.gc();\n            }\n            \n            // æµ‹è¯•é—´éš”\n            await this.sleep(1000);\n        }\n        \n        // è¾“å‡ºæ±‡æ€»æŠ¥å‘Š\n        this.printSummaryReport(results);\n        \n        return results;\n    }\n    \n    /**\n     * è¿è¡Œå•ä¸ªæ€§èƒ½æµ‹è¯•\n     */\n    private async runSingleTest(config: PerformanceTestConfig): Promise<TestResult> {\n        const result: TestResult = {\n            testName: config.testName,\n            passed: false,\n            metrics: {\n                avgRenderTime: 0,\n                maxRenderTime: 0,\n                minRenderTime: Infinity,\n                avgMemoryUsage: 0,\n                maxMemoryUsage: 0,\n                fps: 0,\n                samplesPerSecond: 0\n            },\n            errors: [],\n            warnings: []\n        };\n        \n        try {\n            // ç”Ÿæˆæµ‹è¯•æ•°æ®\n            console.log(`  ğŸ“ˆ ç”Ÿæˆ ${config.sampleCount} æ ·æœ¬æ•°æ®...`);\n            const testData = await this.generateTestData(config);\n            \n            // éªŒè¯æ•°æ®æ ¼å¼\n            if (!UnifiedDataFormat.validate(testData)) {\n                result.errors.push('æ•°æ®æ ¼å¼éªŒè¯å¤±è´¥');\n                return result;\n            }\n            \n            // åˆå§‹åŒ–æ¸²æŸ“å™¨\n            this.initializeRenderer();\n            if (!this.renderer) {\n                result.errors.push('æ¸²æŸ“å™¨åˆå§‹åŒ–å¤±è´¥');\n                return result;\n            }\n            \n            // å†…å­˜ç›‘æ§å¼€å§‹\n            this.memoryMonitor.start();\n            \n            // è¿è¡Œæ¸²æŸ“æ€§èƒ½æµ‹è¯•\n            const renderTimes: number[] = [];\n            \n            for (let i = 0; i < config.iterations; i++) {\n                const startTime = performance.now();\n                \n                // æ‰§è¡Œæ¸²æŸ“\n                const renderStats = this.renderer.renderWaveform(testData, {\n                    startSample: 0,\n                    endSample: Math.min(config.sampleCount, 10000),\n                    samplesPerPixel: config.sampleCount / 1200,\n                    timePerPixel: 1000,\n                    zoomLevel: 1\n                });\n                \n                const endTime = performance.now();\n                const renderTime = endTime - startTime;\n                renderTimes.push(renderTime);\n                \n                // ç›‘æ§å†…å­˜ä½¿ç”¨\n                this.memoryMonitor.measure();\n                \n                // é¿å…æµè§ˆå™¨é˜»å¡\n                if (i % 2 === 0) {\n                    await this.sleep(10);\n                }\n            }\n            \n            // è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡\n            result.metrics.avgRenderTime = renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length;\n            result.metrics.maxRenderTime = Math.max(...renderTimes);\n            result.metrics.minRenderTime = Math.min(...renderTimes);\n            \n            const memoryStats = this.memoryMonitor.getStats();\n            result.metrics.avgMemoryUsage = memoryStats.avg;\n            result.metrics.maxMemoryUsage = memoryStats.max;\n            \n            result.metrics.fps = 1000 / result.metrics.avgRenderTime;\n            result.metrics.samplesPerSecond = config.sampleCount / (result.metrics.avgRenderTime / 1000);\n            \n            // æµ‹è¯•äº¤äº’æ€§èƒ½\n            await this.testInteractionPerformance(testData, result);\n            \n            // éªŒè¯æ€§èƒ½åŸºå‡†\n            result.passed = this.validatePerformance(result.metrics, config, result);\n            \n        } catch (error) {\n            result.errors.push(`æµ‹è¯•æ‰§è¡Œé”™è¯¯: ${error}`);\n        } finally {\n            this.cleanup();\n        }\n        \n        return result;\n    }\n    \n    /**\n     * æµ‹è¯•äº¤äº’æ€§èƒ½\n     */\n    private async testInteractionPerformance(testData: any, result: TestResult): Promise<void> {\n        if (!this.interactionEngine) {\n            this.interactionEngine = new InteractionEngine(this.canvas, {\n                startSample: 0,\n                endSample: 10000,\n                samplesPerPixel: 1,\n                timePerPixel: 1000,\n                zoomLevel: 1\n            });\n        }\n        \n        // æµ‹è¯•ç¼©æ”¾æ€§èƒ½\n        const zoomTimes: number[] = [];\n        for (let i = 0; i < 5; i++) {\n            const startTime = performance.now();\n            this.interactionEngine.zoomIn(1.5);\n            const endTime = performance.now();\n            zoomTimes.push(endTime - startTime);\n        }\n        \n        const avgZoomTime = zoomTimes.reduce((a, b) => a + b, 0) / zoomTimes.length;\n        \n        if (avgZoomTime > 50) {\n            result.warnings.push(`ç¼©æ”¾å“åº”æ—¶é—´ ${avgZoomTime.toFixed(2)}ms è¶…è¿‡é¢„æœŸ (50ms)`);\n        }\n    }\n    \n    /**\n     * éªŒè¯æ€§èƒ½æ˜¯å¦ç¬¦åˆåŸºå‡†\n     */\n    private validatePerformance(\n        metrics: TestResult['metrics'], \n        config: PerformanceTestConfig, \n        result: TestResult\n    ): boolean {\n        let passed = true;\n        \n        // æ¸²æŸ“æ—¶é—´æ£€æŸ¥\n        if (metrics.avgRenderTime > config.expectedRenderTime) {\n            result.errors.push(\n                `å¹³å‡æ¸²æŸ“æ—¶é—´ ${metrics.avgRenderTime.toFixed(2)}ms è¶…è¿‡é¢„æœŸ ${config.expectedRenderTime}ms`\n            );\n            passed = false;\n        }\n        \n        // å†…å­˜ä½¿ç”¨æ£€æŸ¥\n        if (metrics.maxMemoryUsage > config.expectedMemoryLimit) {\n            result.errors.push(\n                `æœ€å¤§å†…å­˜ä½¿ç”¨ ${metrics.maxMemoryUsage.toFixed(2)}MB è¶…è¿‡é™åˆ¶ ${config.expectedMemoryLimit}MB`\n            );\n            passed = false;\n        }\n        \n        // å¸§ç‡æ£€æŸ¥\n        if (metrics.fps < 30) {\n            result.warnings.push(\n                `å¸§ç‡ ${metrics.fps.toFixed(1)}fps ä½äºå»ºè®®å€¼ 30fps`\n            );\n        }\n        \n        // ååé‡æ£€æŸ¥\n        const expectedThroughput = config.sampleCount * 10; // æ¯ç§’è‡³å°‘å¤„ç†10å€æ ·æœ¬\n        if (metrics.samplesPerSecond < expectedThroughput) {\n            result.warnings.push(\n                `æ ·æœ¬å¤„ç†ååé‡ ${metrics.samplesPerSecond.toFixed(0)} samples/s ä½äºé¢„æœŸ`\n            );\n        }\n        \n        return passed;\n    }\n    \n    /**\n     * ç”Ÿæˆæµ‹è¯•æ•°æ®\n     */\n    private async generateTestData(config: PerformanceTestConfig) {\n        const generatorConfig: GeneratorConfig = {\n            deviceType: AnalyzerDriverType.Serial,\n            channelCount: config.channelCount,\n            sampleRate: config.sampleRate,\n            sampleCount: config.sampleCount,\n            patterns: this.generateTestPatterns(config.channelCount),\n            noiseLevel: 0.01, // 1%å™ªå£°\n            jitter: 1\n        };\n        \n        return MockDataGenerator.generateCaptureData(generatorConfig);\n    }\n    \n    /**\n     * ç”Ÿæˆæµ‹è¯•æ¨¡å¼\n     */\n    private generateTestPatterns(channelCount: number) {\n        const patterns = [];\n        \n        for (let i = 0; i < channelCount; i++) {\n            if (i % 4 === 0) {\n                patterns.push({ channel: i, pattern: SignalPattern.Clock, frequency: 1000000 * (i + 1) });\n            } else if (i % 4 === 1) {\n                patterns.push({ channel: i, pattern: SignalPattern.Counter });\n            } else if (i % 4 === 2) {\n                patterns.push({ channel: i, pattern: SignalPattern.Random });\n            } else {\n                patterns.push({ channel: i, pattern: SignalPattern.PWM, frequency: 10000, dutyCycle: 0.5 });\n            }\n        }\n        \n        return patterns;\n    }\n    \n    /**\n     * åˆå§‹åŒ–æ¸²æŸ“å™¨\n     */\n    private initializeRenderer(): void {\n        try {\n            this.renderer = new WaveformRenderer(this.canvas);\n        } catch (error) {\n            console.error('æ¸²æŸ“å™¨åˆå§‹åŒ–å¤±è´¥:', error);\n        }\n    }\n    \n    /**\n     * åˆ›å»ºè™šæ‹ŸCanvas\n     */\n    private createVirtualCanvas(width: number, height: number): HTMLCanvasElement {\n        // åœ¨Node.jsç¯å¢ƒä¸­ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨canvasåº“\n        // åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­ï¼Œç›´æ¥åˆ›å»ºCanvaså…ƒç´ \n        if (typeof document !== 'undefined') {\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            return canvas;\n        } else {\n            // Node.jsç¯å¢ƒçš„æ¨¡æ‹Ÿå®ç°\n            return {\n                width,\n                height,\n                getContext: () => ({\n                    clearRect: () => {},\n                    fillRect: () => {},\n                    strokeRect: () => {},\n                    beginPath: () => {},\n                    moveTo: () => {},\n                    lineTo: () => {},\n                    stroke: () => {},\n                    fill: () => {},\n                    fillText: () => {},\n                    measureText: () => ({ width: 50 }),\n                    scale: () => {},\n                    save: () => {},\n                    restore: () => {},\n                    drawImage: () => {}\n                }),\n                addEventListener: () => {},\n                removeEventListener: () => {},\n                getBoundingClientRect: () => ({ left: 0, top: 0, width, height }),\n                style: {}\n            } as any;\n        }\n    }\n    \n    /**\n     * è¾“å‡ºæµ‹è¯•ç»“æœ\n     */\n    private printTestResult(result: TestResult): void {\n        const status = result.passed ? 'âœ… PASS' : 'âŒ FAIL';\n        console.log(`  ${status} ${result.testName}`);\n        console.log(`    å¹³å‡æ¸²æŸ“æ—¶é—´: ${result.metrics.avgRenderTime.toFixed(2)}ms`);\n        console.log(`    æœ€å¤§æ¸²æŸ“æ—¶é—´: ${result.metrics.maxRenderTime.toFixed(2)}ms`);\n        console.log(`    å¹³å‡å†…å­˜ä½¿ç”¨: ${result.metrics.avgMemoryUsage.toFixed(2)}MB`);\n        console.log(`    æœ€å¤§å†…å­˜ä½¿ç”¨: ${result.metrics.maxMemoryUsage.toFixed(2)}MB`);\n        console.log(`    å¸§ç‡: ${result.metrics.fps.toFixed(1)}fps`);\n        console.log(`    æ ·æœ¬åå: ${(result.metrics.samplesPerSecond / 1000000).toFixed(1)}M samples/s`);\n        \n        if (result.errors.length > 0) {\n            console.log(`    é”™è¯¯:`);\n            result.errors.forEach(error => console.log(`      - ${error}`));\n        }\n        \n        if (result.warnings.length > 0) {\n            console.log(`    è­¦å‘Š:`);\n            result.warnings.forEach(warning => console.log(`      - ${warning}`));\n        }\n    }\n    \n    /**\n     * è¾“å‡ºæ±‡æ€»æŠ¥å‘Š\n     */\n    private printSummaryReport(results: TestResult[]): void {\n        console.log('\\nğŸ“‹ Week 2 æ€§èƒ½æµ‹è¯•æ±‡æ€»æŠ¥å‘Š');\n        console.log('=' .repeat(50));\n        \n        const passed = results.filter(r => r.passed).length;\n        const total = results.length;\n        \n        console.log(`æ€»æµ‹è¯•æ•°: ${total}`);\n        console.log(`é€šè¿‡æµ‹è¯•: ${passed}`);\n        console.log(`å¤±è´¥æµ‹è¯•: ${total - passed}`);\n        console.log(`é€šè¿‡ç‡: ${(passed / total * 100).toFixed(1)}%`);\n        \n        // æ€§èƒ½ç»Ÿè®¡\n        const allMetrics = results.map(r => r.metrics);\n        const avgRenderTime = allMetrics.reduce((sum, m) => sum + m.avgRenderTime, 0) / allMetrics.length;\n        const maxMemoryUsage = Math.max(...allMetrics.map(m => m.maxMemoryUsage));\n        const avgFps = allMetrics.reduce((sum, m) => sum + m.fps, 0) / allMetrics.length;\n        \n        console.log('\\nğŸ¯ æ€§èƒ½åŸºå‡†è¯„ä¼°:');\n        console.log(`  å¹³å‡æ¸²æŸ“æ—¶é—´: ${avgRenderTime.toFixed(2)}ms (ç›®æ ‡: <16ms)`);\n        console.log(`  æœ€å¤§å†…å­˜ä½¿ç”¨: ${maxMemoryUsage.toFixed(2)}MB (ç›®æ ‡: <100MB)`);\n        console.log(`  å¹³å‡å¸§ç‡: ${avgFps.toFixed(1)}fps (ç›®æ ‡: >30fps)`);\n        \n        // åŸºå‡†è¾¾æˆæƒ…å†µ\n        const renderTimeBenchmark = avgRenderTime < 16;\n        const memoryBenchmark = maxMemoryUsage < 100;\n        const fpsBenchmark = avgFps > 30;\n        \n        console.log('\\nğŸ“Š åŸºå‡†è¾¾æˆæƒ…å†µ:');\n        console.log(`  æ¸²æŸ“æ€§èƒ½: ${renderTimeBenchmark ? 'âœ… è¾¾æˆ' : 'âŒ æœªè¾¾æˆ'}`);\n        console.log(`  å†…å­˜ä½¿ç”¨: ${memoryBenchmark ? 'âœ… è¾¾æˆ' : 'âŒ æœªè¾¾æˆ'}`);\n        console.log(`  å¸§ç‡è¡¨ç°: ${fpsBenchmark ? 'âœ… è¾¾æˆ' : 'âŒ æœªè¾¾æˆ'}`);\n        \n        const overallSuccess = renderTimeBenchmark && memoryBenchmark && fpsBenchmark;\n        console.log(`\\nğŸ† Week 2 æ€§èƒ½ç›®æ ‡: ${overallSuccess ? 'âœ… å…¨éƒ¨è¾¾æˆ' : 'âŒ éƒ¨åˆ†æœªè¾¾æˆ'}`);\n        \n        if (!overallSuccess) {\n            console.log('\\nğŸ”§ ä¼˜åŒ–å»ºè®®:');\n            if (!renderTimeBenchmark) {\n                console.log('  - ä¼˜åŒ–æ¸²æŸ“ç®—æ³•ï¼Œè€ƒè™‘ä½¿ç”¨WebGLåŠ é€Ÿ');\n                console.log('  - å®ç°æ›´æ¿€è¿›çš„LODç­–ç•¥');\n                console.log('  - ä½¿ç”¨Web Workersè¿›è¡Œæ•°æ®é¢„å¤„ç†');\n            }\n            if (!memoryBenchmark) {\n                console.log('  - å®ç°æ•°æ®åˆ†é¡µåŠ è½½');\n                console.log('  - ä¼˜åŒ–ç¼“å­˜ç­–ç•¥ï¼ŒåŠæ—¶é‡Šæ”¾ä¸ç”¨çš„æ•°æ®');\n                console.log('  - ä½¿ç”¨æ›´é«˜æ•ˆçš„æ•°æ®ç»“æ„');\n            }\n            if (!fpsBenchmark) {\n                console.log('  - ä½¿ç”¨requestAnimationFrameä¼˜åŒ–åŠ¨ç”»');\n                console.log('  - å‡å°‘é‡ç»˜é¢‘ç‡');\n                console.log('  - ä¼˜åŒ–äº¤äº’å“åº”æœºåˆ¶');\n            }\n        }\n    }\n    \n    /**\n     * è¿è¡ŒCapabilityAdapteræ€§èƒ½æµ‹è¯•\n     */\n    async testCapabilityAdapter(): Promise<void> {\n        console.log('\\nğŸ”§ æµ‹è¯•CapabilityAdapteræ€§èƒ½...');\n        \n        const adapter = new CapabilityAdapter({\n            strategy: AdaptationStrategy.Adaptive\n        });\n        \n        // åˆ›å»ºæµ‹è¯•é…ç½®\n        const testConfigs: CaptureConfiguration[] = [\n            {\n                frequency: 100000000,\n                preTriggerSamples: 50000,\n                postTriggerSamples: 950000,\n                triggerType: TriggerType.Edge,\n                triggerChannel: 0,\n                triggerInverted: false,\n                loopCount: 0,\n                measureBursts: false,\n                captureChannels: Array.from({length: 24}, (_, i) => i)\n            }\n        ];\n        \n        const deviceInfo = {\n            name: 'Test Device',\n            type: AnalyzerDriverType.Serial,\n            isNetwork: false,\n            capabilities: {} as any\n        };\n        \n        const startTime = performance.now();\n        \n        // è¿è¡Œé€‚é…æµ‹è¯•\n        for (let i = 0; i < 100; i++) {\n            const result = adapter.adaptConfiguration(testConfigs[0], deviceInfo);\n            if (!result.success) {\n                console.log(`  é€‚é…å¤±è´¥: ${result.errors.join(', ')}`);\n            }\n        }\n        \n        const endTime = performance.now();\n        const avgTime = (endTime - startTime) / 100;\n        \n        console.log(`  å¹³å‡é€‚é…æ—¶é—´: ${avgTime.toFixed(3)}ms`);\n        console.log(`  é€‚é…æ€§èƒ½: ${avgTime < 1 ? 'âœ… ä¼˜ç§€' : avgTime < 5 ? 'âš ï¸ è‰¯å¥½' : 'âŒ éœ€ä¼˜åŒ–'}`);\n    }\n    \n    /**\n     * å·¥å…·æ–¹æ³•\n     */\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    private cleanup(): void {\n        if (this.renderer) {\n            this.renderer.dispose();\n            this.renderer = null;\n        }\n        \n        if (this.interactionEngine) {\n            this.interactionEngine.dispose();\n            this.interactionEngine = null;\n        }\n    }\n}\n\n// ä¸»æµ‹è¯•å…¥å£\nexport async function runWeek2PerformanceTests(): Promise<void> {\n    const tester = new Week2PerformanceTest();\n    \n    try {\n        const results = await tester.runAllTests();\n        \n        // è¿è¡ŒCapabilityAdapteræµ‹è¯•\n        await tester.testCapabilityAdapter();\n        \n        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ ¸å¿ƒæµ‹è¯•éƒ½é€šè¿‡\n        const criticalTests = results.filter(r => \n            r.testName.includes('100ä¸‡æ ·æœ¬') || \n            r.testName.includes('åŸºå‡†æ€§èƒ½')\n        );\n        \n        const allCriticalPassed = criticalTests.every(r => r.passed);\n        \n        if (allCriticalPassed) {\n            console.log('\\nğŸ‰ Week 2 æ€§èƒ½æµ‹è¯•å…¨éƒ¨é€šè¿‡ï¼ç³»ç»Ÿå·²å‡†å¤‡å¥½è¿›å…¥Week 3å¼€å‘ã€‚');\n        } else {\n            console.log('\\nâš ï¸ éƒ¨åˆ†å…³é”®æ€§èƒ½æµ‹è¯•æœªé€šè¿‡ï¼Œå»ºè®®ä¼˜åŒ–åå†è¿›å…¥ä¸‹ä¸€é˜¶æ®µã€‚');\n        }\n        \n    } catch (error) {\n        console.error('æ€§èƒ½æµ‹è¯•æ‰§è¡Œå¤±è´¥:', error);\n    }\n}\n\n// å¦‚æœç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶\nif (require.main === module) {\n    runWeek2PerformanceTests();\n}"